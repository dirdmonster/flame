//木棉树软件
/*  1、PMREMCubeUVPacker.js
 *  2、PMREMGenerator.js
 *  3、EffectComposer.js
 *  4、RenderPass.js
 *  5、ShaderPass.js
 *  6、MaskPass.js
 *  7、CopyShader.js
 *  8、FXAAShader.js
 *  9、UnrealBloomPass.js
 *  10、SMAAShader.js
 *  11、SMAAPass.js
 *  12、OutlinePass.js
 *  13、SSAARenderPass.js
 *  14、TAARenderPass.js
 *  15、BokehShader.js
 *  16、BokehPass.js
 *  17、AfterimageShader.js
 *  18、AfterimagePass.js
 */


 THREE.PMREMCubeUVPacker=function(){var d=new THREE.OrthographicCamera,k=new THREE.Scene,r=function(){var a=new THREE.ShaderMaterial({uniforms:{faceIndex:{value:0},mapSize:{value:0},envMap:{value:null},testColor:{value:new THREE.Vector3(1,1,1)}},vertexShader:"precision highp float;\r\n        varying vec2 vUv;\r\n        void main() {\r\n          vUv \x3d uv;\r\n          gl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }",fragmentShader:"precision highp float;\r\n        varying vec2 vUv;\r\n        uniform samplerCube envMap;\r\n        uniform float mapSize;\r\n        uniform vec3 testColor;\r\n        uniform int faceIndex;\r\n        \r\n        void main() {\r\n          vec3 sampleDirection;\r\n          vec2 uv \x3d vUv;\r\n          uv \x3d uv * 2.0 - 1.0;\r\n          uv.y *\x3d -1.0;\r\n          if(faceIndex \x3d\x3d 0) {\r\n            sampleDirection \x3d normalize(vec3(1.0, uv.y, -uv.x));\r\n          } else if(faceIndex \x3d\x3d 1) {\r\n            sampleDirection \x3d normalize(vec3(uv.x, 1.0, uv.y));\r\n          } else if(faceIndex \x3d\x3d 2) {\r\n            sampleDirection \x3d normalize(vec3(uv.x, uv.y, 1.0));\r\n          } else if(faceIndex \x3d\x3d 3) {\r\n            sampleDirection \x3d normalize(vec3(-1.0, uv.y, uv.x));\r\n          } else if(faceIndex \x3d\x3d 4) {\r\n            sampleDirection \x3d normalize(vec3(uv.x, -1.0, -uv.y));\r\n          } else {\r\n            sampleDirection \x3d normalize(vec3(-uv.x, uv.y, -1.0));\r\n          }\r\n          vec4 color \x3d envMapTexelToLinear( textureCube( envMap, sampleDirection ) );\r\n          gl_FragColor \x3d linearToOutputTexel( color );\r\n        }",blending:THREE.NoBlending});a.type="PMREMCubeUVPacker";return a}(),g=function(a){this.cubeLods=a;var b=4*a[0].width,c=a[0].texture,c={format:c.format,magFilter:c.magFilter,minFilter:c.minFilter,type:c.type,generateMipmaps:c.generateMipmaps,anisotropy:c.anisotropy,encoding:c.encoding===THREE.RGBEEncoding?THREE.RGBM16Encoding:c.encoding};c.encoding===THREE.RGBM16Encoding&&(c.magFilter=THREE.LinearFilter,c.minFilter=THREE.LinearFilter);this.CubeUVRenderTarget=new THREE.WebGLRenderTarget(b,b,c);this.CubeUVRenderTarget.texture.name="PMREMCubeUVPacker.cubeUv";this.CubeUVRenderTarget.texture.mapping=THREE.CubeUVReflectionMapping;this.objects=[];var c=new THREE.PlaneBufferGeometry(1,1),f=[];f.push(new THREE.Vector2(0,0));f.push(new THREE.Vector2(1,0));f.push(new THREE.Vector2(2,0));f.push(new THREE.Vector2(0,1));f.push(new THREE.Vector2(1,1));f.push(new THREE.Vector2(2,1));var d=b,b=a[0].width,m=0,k=4;this.numLods=Math.log(a[0].width)/Math.log(2)-2;for(a=0;a<this.numLods;a++){var g=.5*(d-d/k);16<b&&(k*=2);for(var t=16<b?6:1,n=0,p=0,h=b,q=0;q<t;q++){for(var l=0;6>l;l++){var e=r.clone();e.uniforms.envMap.value=this.cubeLods[a].texture;e.envMap=this.cubeLods[a].texture;e.uniforms.faceIndex.value=l;e.uniforms.mapSize.value=h;e=new THREE.Mesh(c,e);e.position.x=f[l].x*h-g+n;e.position.y=f[l].y*h-g+m+p;e.material.side=THREE.BackSide;e.scale.setScalar(h);this.objects.push(e)}p+=1.75*h;n+=1.25*h;h/=2}m+=2*b;16<b&&(b/=2)}};g.prototype={constructor:g,update:function(a){var b=4*this.cubeLods[0].width;d.left=.5*-b;d.right=.5*b;d.top=.5*-b;d.bottom=.5*b;d.near=0;d.far=1;d.updateProjectionMatrix();for(b=0;b<this.objects.length;b++)k.add(this.objects[b]);var b=a.gammaInput,c=a.gammaOutput,f=a.toneMapping,g=a.toneMappingExposure,m=a.getRenderTarget();a.gammaInput=!1;a.gammaOutput=!1;a.toneMapping=THREE.LinearToneMapping;a.toneMappingExposure=1;a.setRenderTarget(this.CubeUVRenderTarget);a.render(k,d);a.setRenderTarget(m);a.toneMapping=f;a.toneMappingExposure=g;a.gammaInput=b;a.gammaOutput=c;for(b=0;b<this.objects.length;b++)k.remove(this.objects[b])},dispose:function(){for(var a=0,b=this.objects.length;a<b;a++)this.objects[a].material.dispose();this.objects[0].geometry.dispose()}};return g}();
THREE.PMREMGenerator=function(){var a=function(){var a=new THREE.ShaderMaterial({defines:{SAMPLES_PER_LEVEL:20},uniforms:{faceIndex:{value:0},roughness:{value:.5},mapSize:{value:.5},envMap:{value:null},tFlip:{value:-1}},vertexShader:"varying vec2 vUv;\n\r\n\t\t\t\tvoid main() {\n\r\n\t\t\t\t\tvUv \x3d uv;\n\r\n\t\t\t\t\tgl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\r\n\t\t\t\t}",fragmentShader:"#include \x3ccommon\x3e\n\r\n\t\t\t\tvarying vec2 vUv;\n\r\n\t\t\t\tuniform int faceIndex;\n\r\n\t\t\t\tuniform float roughness;\n\r\n\t\t\t\tuniform samplerCube envMap;\n\r\n\t\t\t\tuniform float mapSize;\n\r\n\t\t\t\tuniform float tFlip;\n\r\n\t\t\t\t\n\r\n\t\t\t\tfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\r\n\t\t\t\t\tfloat a \x3d ggxRoughness + 0.0001;\n\r\n\t\t\t\t\ta *\x3d a;\n\r\n\t\t\t\t\treturn ( 2.0 / a - 2.0 );\n\r\n\t\t\t\t}\n\r\n\t\t\t\tvec3 ImportanceSamplePhong(vec2 uv, mat3 vecSpace, float specPow) {\n\r\n\t\t\t\t\tfloat phi \x3d uv.y * 2.0 * PI;\n\r\n\t\t\t\t\tfloat cosTheta \x3d pow(1.0 - uv.x, 1.0 / (specPow + 1.0));\n\r\n\t\t\t\t\tfloat sinTheta \x3d sqrt(1.0 - cosTheta * cosTheta);\n\r\n\t\t\t\t\tvec3 sampleDir \x3d vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n\r\n\t\t\t\t\treturn vecSpace * sampleDir;\n\r\n\t\t\t\t}\n\r\n\t\t\t\tvec3 ImportanceSampleGGX( vec2 uv, mat3 vecSpace, float Roughness )\n\r\n\t\t\t\t{\n\r\n\t\t\t\t\tfloat a \x3d Roughness * Roughness;\n\r\n\t\t\t\t\tfloat Phi \x3d 2.0 * PI * uv.x;\n\r\n\t\t\t\t\tfloat CosTheta \x3d sqrt( (1.0 - uv.y) / ( 1.0 + (a*a - 1.0) * uv.y ) );\n\r\n\t\t\t\t\tfloat SinTheta \x3d sqrt( 1.0 - CosTheta * CosTheta );\n\r\n\t\t\t\t\treturn vecSpace * vec3(SinTheta * cos( Phi ), SinTheta * sin( Phi ), CosTheta);\n\r\n\t\t\t\t}\n\r\n\t\t\t\tmat3 matrixFromVector(vec3 n) {\n\r\n\t\t\t\t\tfloat a \x3d 1.0 / (1.0 + n.z);\n\r\n\t\t\t\t\tfloat b \x3d -n.x * n.y * a;\n\r\n\t\t\t\t\tvec3 b1 \x3d vec3(1.0 - n.x * n.x * a, b, -n.x);\n\r\n\t\t\t\t\tvec3 b2 \x3d vec3(b, 1.0 - n.y * n.y * a, -n.y);\n\r\n\t\t\t\t\treturn mat3(b1, b2, n);\n\r\n\t\t\t\t}\n\r\n\t\t\t\t\n\r\n\t\t\t\tvec4 testColorMap(float Roughness) {\n\r\n\t\t\t\t\tvec4 color;\n\r\n\t\t\t\t\tif(faceIndex \x3d\x3d 0)\n\r\n\t\t\t\t\t\tcolor \x3d vec4(1.0,0.0,0.0,1.0);\n\r\n\t\t\t\t\telse if(faceIndex \x3d\x3d 1)\n\r\n\t\t\t\t\t\tcolor \x3d vec4(0.0,1.0,0.0,1.0);\n\r\n\t\t\t\t\telse if(faceIndex \x3d\x3d 2)\n\r\n\t\t\t\t\t\tcolor \x3d vec4(0.0,0.0,1.0,1.0);\n\r\n\t\t\t\t\telse if(faceIndex \x3d\x3d 3)\n\r\n\t\t\t\t\t\tcolor \x3d vec4(1.0,1.0,0.0,1.0);\n\r\n\t\t\t\t\telse if(faceIndex \x3d\x3d 4)\n\r\n\t\t\t\t\t\tcolor \x3d vec4(0.0,1.0,1.0,1.0);\n\r\n\t\t\t\t\telse\n\r\n\t\t\t\t\t\tcolor \x3d vec4(1.0,0.0,1.0,1.0);\n\r\n\t\t\t\t\tcolor *\x3d ( 1.0 - Roughness );\n\r\n\t\t\t\t\treturn color;\n\r\n\t\t\t\t}\n\r\n\t\t\t\tvoid main() {\n\r\n\t\t\t\t\tvec3 sampleDirection;\n\r\n\t\t\t\t\tvec2 uv \x3d vUv*2.0 - 1.0;\n\r\n\t\t\t\t\tfloat offset \x3d -1.0/mapSize;\n\r\n\t\t\t\t\tconst float a \x3d -1.0;\n\r\n\t\t\t\t\tconst float b \x3d 1.0;\n\r\n\t\t\t\t\tfloat c \x3d -1.0 + offset;\n\r\n\t\t\t\t\tfloat d \x3d 1.0 - offset;\n\r\n\t\t\t\t\tfloat bminusa \x3d b - a;\n\r\n\t\t\t\t\tuv.x \x3d (uv.x - a)/bminusa * d - (uv.x - b)/bminusa * c;\n\r\n\t\t\t\t\tuv.y \x3d (uv.y - a)/bminusa * d - (uv.y - b)/bminusa * c;\n\r\n\t\t\t\t\tif (faceIndex\x3d\x3d0) {\n\r\n\t\t\t\t\t\tsampleDirection \x3d vec3(1.0, -uv.y, -uv.x);\n\r\n\t\t\t\t\t} else if (faceIndex\x3d\x3d1) {\n\r\n\t\t\t\t\t\tsampleDirection \x3d vec3(-1.0, -uv.y, uv.x);\n\r\n\t\t\t\t\t} else if (faceIndex\x3d\x3d2) {\n\r\n\t\t\t\t\t\tsampleDirection \x3d vec3(uv.x, 1.0, uv.y);\n\r\n\t\t\t\t\t} else if (faceIndex\x3d\x3d3) {\n\r\n\t\t\t\t\t\tsampleDirection \x3d vec3(uv.x, -1.0, -uv.y);\n\r\n\t\t\t\t\t} else if (faceIndex\x3d\x3d4) {\n\r\n\t\t\t\t\t\tsampleDirection \x3d vec3(uv.x, -uv.y, 1.0);\n\r\n\t\t\t\t\t} else {\n\r\n\t\t\t\t\t\tsampleDirection \x3d vec3(-uv.x, -uv.y, -1.0);\n\r\n\t\t\t\t\t}\n\r\n\t\t\t\t\tvec3 correctedDirection \x3d vec3( tFlip * sampleDirection.x, sampleDirection.yz );\n\r\n\t\t\t\t\tmat3 vecSpace \x3d matrixFromVector( normalize( correctedDirection ) );\n\r\n\t\t\t\t\tvec3 rgbColor \x3d vec3(0.0);\n\r\n\t\t\t\t\tconst int NumSamples \x3d SAMPLES_PER_LEVEL;\n\r\n\t\t\t\t\tvec3 vect;\n\r\n\t\t\t\t\tfloat weight \x3d 0.0;\n\r\n\t\t\t\t\tfor( int i \x3d 0; i \x3c NumSamples; i ++ ) {\n\r\n\t\t\t\t\t\tfloat sini \x3d sin(float(i));\n\r\n\t\t\t\t\t\tfloat cosi \x3d cos(float(i));\n\r\n\t\t\t\t\t\tfloat r \x3d rand(vec2(sini, cosi));\n\r\n\t\t\t\t\t\tvect \x3d ImportanceSampleGGX(vec2(float(i) / float(NumSamples), r), vecSpace, roughness);\n\r\n\t\t\t\t\t\tfloat dotProd \x3d dot(vect, normalize(sampleDirection));\n\r\n\t\t\t\t\t\tweight +\x3d dotProd;\n\r\n\t\t\t\t\t\tvec3 color \x3d envMapTexelToLinear(textureCube(envMap, vect)).rgb;\n\r\n\t\t\t\t\t\trgbColor.rgb +\x3d color;\n\r\n\t\t\t\t\t}\n\r\n\t\t\t\t\trgbColor /\x3d float(NumSamples);\n\r\n\t\t\t\t\t//rgbColor \x3d testColorMap( roughness ).rgb;\n\r\n\t\t\t\t\tgl_FragColor \x3d linearToOutputTexel( vec4( rgbColor, 1.0 ) );\n\r\n\t\t\t\t}",blending:THREE.NoBlending});a.type="PMREMGenerator";return a}(),b=new THREE.OrthographicCamera(-1,1,1,-1,0,1E3),c=new THREE.Scene,d=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2,0),a);d.material.side=THREE.DoubleSide;c.add(d);c.add(b);d=function(a,b,c){this.sourceTexture=a;this.resolution=void 0!==c?c:256;this.samplesPerLevel=void 0!==b?b:32;a=this.sourceTexture.encoding===THREE.LinearEncoding||this.sourceTexture.encoding===THREE.GammaEncoding||this.sourceTexture.encoding===THREE.sRGBEncoding;this.sourceTexture.minFilter=a?THREE.LinearFilter:THREE.NearestFilter;this.sourceTexture.magFilter=a?THREE.LinearFilter:THREE.NearestFilter;this.sourceTexture.generateMipmaps=this.sourceTexture.generateMipmaps&&a;this.cubeLods=[];a=this.resolution;b={format:this.sourceTexture.format,magFilter:this.sourceTexture.magFilter,minFilter:this.sourceTexture.minFilter,type:this.sourceTexture.type,generateMipmaps:this.sourceTexture.generateMipmaps,anisotropy:this.sourceTexture.anisotropy,encoding:this.sourceTexture.encoding};this.numLods=Math.log(a)/Math.log(2)-2;for(c=0;c<this.numLods;c++){var e=new THREE.WebGLRenderTargetCube(a,a,b);e.texture.name="PMREMGenerator.cube"+c;this.cubeLods.push(e);a=Math.max(16,a/2)}};d.prototype={constructor:d,update:function(b){var c=this.sourceTexture.isCubeTexture?-1:1;a.defines.SAMPLES_PER_LEVEL=this.samplesPerLevel;a.uniforms.faceIndex.value=0;a.uniforms.envMap.value=this.sourceTexture;a.envMap=this.sourceTexture;a.needsUpdate=!0;var e=b.gammaInput,d=b.gammaOutput,h=b.toneMapping,k=b.toneMappingExposure,n=b.getRenderTarget();b.toneMapping=THREE.LinearToneMapping;b.toneMappingExposure=1;b.gammaInput=!1;b.gammaOutput=!1;for(var l=0;l<this.numLods;l++)a.uniforms.roughness.value=l/(this.numLods-1)*.9,a.uniforms.tFlip.value=0==l?c:1,a.uniforms.mapSize.value=this.cubeLods[l].width,this.renderToCubeMapTarget(b,this.cubeLods[l]),5>l&&(a.uniforms.envMap.value=this.cubeLods[l].texture);b.setRenderTarget(n);b.toneMapping=h;b.toneMappingExposure=k;b.gammaInput=e;b.gammaOutput=d},renderToCubeMapTarget:function(a,b){for(var c=0;6>c;c++)this.renderToCubeMapTargetFace(a,b,c)},renderToCubeMapTargetFace:function(e,d,g){a.uniforms.faceIndex.value=g;e.setRenderTarget(d,g);e.clear();e.render(c,b)},dispose:function(){for(var a=0,b=this.cubeLods.length;a<b;a++)this.cubeLods[a].dispose()}};return d}();THREE.PMREMCubeUVPacker=function(){var a=new THREE.OrthographicCamera,b=new THREE.Scene,c=function(){var a=new THREE.ShaderMaterial({uniforms:{faceIndex:{value:0},mapSize:{value:0},envMap:{value:null},testColor:{value:new THREE.Vector3(1,1,1)}},vertexShader:"precision highp float;\r\n        varying vec2 vUv;\r\n        void main() {\r\n          vUv \x3d uv;\r\n          gl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }",fragmentShader:"precision highp float;\r\n        varying vec2 vUv;\r\n        uniform samplerCube envMap;\r\n        uniform float mapSize;\r\n        uniform vec3 testColor;\r\n        uniform int faceIndex;\r\n        \r\n        void main() {\r\n          vec3 sampleDirection;\r\n          vec2 uv \x3d vUv;\r\n          uv \x3d uv * 2.0 - 1.0;\r\n          uv.y *\x3d -1.0;\r\n          if(faceIndex \x3d\x3d 0) {\r\n            sampleDirection \x3d normalize(vec3(1.0, uv.y, -uv.x));\r\n          } else if(faceIndex \x3d\x3d 1) {\r\n            sampleDirection \x3d normalize(vec3(uv.x, 1.0, uv.y));\r\n          } else if(faceIndex \x3d\x3d 2) {\r\n            sampleDirection \x3d normalize(vec3(uv.x, uv.y, 1.0));\r\n          } else if(faceIndex \x3d\x3d 3) {\r\n            sampleDirection \x3d normalize(vec3(-1.0, uv.y, uv.x));\r\n          } else if(faceIndex \x3d\x3d 4) {\r\n            sampleDirection \x3d normalize(vec3(uv.x, -1.0, -uv.y));\r\n          } else {\r\n            sampleDirection \x3d normalize(vec3(-uv.x, uv.y, -1.0));\r\n          }\r\n          vec4 color \x3d envMapTexelToLinear( textureCube( envMap, sampleDirection ) );\r\n          gl_FragColor \x3d linearToOutputTexel( color );\r\n        }",blending:THREE.NoBlending});a.type="PMREMCubeUVPacker";return a}(),d=function(a){this.cubeLods=a;var b=4*a[0].width,d=a[0].texture,d={format:d.format,magFilter:d.magFilter,minFilter:d.minFilter,type:d.type,generateMipmaps:d.generateMipmaps,anisotropy:d.anisotropy,encoding:d.encoding===THREE.RGBEEncoding?THREE.RGBM16Encoding:d.encoding};d.encoding===THREE.RGBM16Encoding&&(d.magFilter=THREE.LinearFilter,d.minFilter=THREE.LinearFilter);this.CubeUVRenderTarget=new THREE.WebGLRenderTarget(b,b,d);this.CubeUVRenderTarget.texture.name="PMREMCubeUVPacker.cubeUv";this.CubeUVRenderTarget.texture.mapping=THREE.CubeUVReflectionMapping;this.objects=[];var d=new THREE.PlaneBufferGeometry(1,1),e=[];e.push(new THREE.Vector2(0,0));e.push(new THREE.Vector2(1,0));e.push(new THREE.Vector2(2,0));e.push(new THREE.Vector2(0,1));e.push(new THREE.Vector2(1,1));e.push(new THREE.Vector2(2,1));var h=b,b=a[0].width,k=0,n=4;this.numLods=Math.log(a[0].width)/Math.log(2)-2;for(a=0;a<this.numLods;a++){var l=.5*(h-h/n);16<b&&(n*=2);for(var w=16<b?6:1,t=0,u=0,p=b,v=0;v<w;v++){for(var r=0;6>r;r++){var m=c.clone();m.uniforms.envMap.value=this.cubeLods[a].texture;m.envMap=this.cubeLods[a].texture;m.uniforms.faceIndex.value=r;m.uniforms.mapSize.value=p;m=new THREE.Mesh(d,m);m.position.x=e[r].x*p-l+t;m.position.y=e[r].y*p-l+k+u;m.material.side=THREE.BackSide;m.scale.setScalar(p);this.objects.push(m)}u+=1.75*p;t+=1.25*p;p/=2}k+=2*b;16<b&&(b/=2)}};d.prototype={constructor:d,update:function(c){var d=4*this.cubeLods[0].width;a.left=.5*-d;a.right=.5*d;a.top=.5*-d;a.bottom=.5*d;a.near=0;a.far=1;a.updateProjectionMatrix();for(d=0;d<this.objects.length;d++)b.add(this.objects[d]);var d=c.gammaInput,e=c.gammaOutput,q=c.toneMapping,h=c.toneMappingExposure,k=c.getRenderTarget();c.gammaInput=!1;c.gammaOutput=!1;c.toneMapping=THREE.LinearToneMapping;c.toneMappingExposure=1;c.setRenderTarget(this.CubeUVRenderTarget);c.render(b,a);c.setRenderTarget(k);c.toneMapping=q;c.toneMappingExposure=h;c.gammaInput=d;c.gammaOutput=e;for(d=0;d<this.objects.length;d++)b.remove(this.objects[d])},dispose:function(){for(var a=0,b=this.objects.length;a<b;a++)this.objects[a].material.dispose();this.objects[0].geometry.dispose()}};return d}();THREE.EffectComposer=function(a,b){this.renderer=a;void 0===b&&(b={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat,stencilBuffer:!1},a=a.getDrawingBufferSize(new THREE.Vector2),b=new THREE.WebGLRenderTarget(a.width,a.height,b),b.texture.name="EffectComposer.rt1");this.renderTarget1=b;this.renderTarget2=b.clone();this.renderTarget2.texture.name="EffectComposer.rt2";this.writeBuffer=this.renderTarget1;this.readBuffer=this.renderTarget2;this.renderToScreen=!0;this.passes=[];void 0===THREE.CopyShader&&console.error("THREE.EffectComposer relies on THREE.CopyShader");void 0===THREE.ShaderPass&&console.error("THREE.EffectComposer relies on THREE.ShaderPass");this.copyPass=new THREE.ShaderPass(THREE.CopyShader);this._previousFrameTime=Date.now()};Object.assign(THREE.EffectComposer.prototype,{swapBuffers:function(){var a=this.readBuffer;this.readBuffer=this.writeBuffer;this.writeBuffer=a},addPass:function(a){this.passes.push(a);var b=this.renderer.getDrawingBufferSize(new THREE.Vector2);a.setSize(b.width,b.height)},insertPass:function(a,b){this.passes.splice(b,0,a)},isLastEnabledPass:function(a){for(a+=1;a<this.passes.length;a++)if(this.passes[a].enabled)return!1;return!0},render:function(a){void 0===a&&(a=.001*(Date.now()-this._previousFrameTime));this._previousFrameTime=Date.now();var b=this.renderer.getRenderTarget(),c=!1,d,e,f=this.passes.length;for(e=0;e<f;e++)if(d=this.passes[e],!1!==d.enabled){d.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(e);d.render(this.renderer,this.writeBuffer,this.readBuffer,a,c);if(d.needsSwap){if(c){var g=this.renderer.context;g.stencilFunc(g.NOTEQUAL,1,4294967295);this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,a);g.stencilFunc(g.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==THREE.MaskPass&&(d instanceof THREE.MaskPass?c=!0:d instanceof THREE.ClearMaskPass&&(c=!1))}this.renderer.setRenderTarget(b)},reset:function(a){if(void 0===a){var b=this.renderer.getDrawingBufferSize(new THREE.Vector2);a=this.renderTarget1.clone();a.setSize(b.width,b.height)}this.renderTarget1.dispose();this.renderTarget2.dispose();this.renderTarget1=a;this.renderTarget2=a.clone();this.writeBuffer=this.renderTarget1;this.readBuffer=this.renderTarget2},setSize:function(a,b){this.renderTarget1.setSize(a,b);this.renderTarget2.setSize(a,b);for(var c=0;c<this.passes.length;c++)this.passes[c].setSize(a,b)}});THREE.Pass=function(){this.needsSwap=this.enabled=!0;this.renderToScreen=this.clear=!1};Object.assign(THREE.Pass.prototype,{setSize:function(a,b){},render:function(a,b,c,d,e){console.error("THREE.Pass: .render() must be implemented in derived pass.")}});THREE.Pass.FullScreenQuad=function(){var a=new THREE.OrthographicCamera(-1,1,1,-1,0,1),b=new THREE.PlaneBufferGeometry(2,2),c=function(a){this._mesh=new THREE.Mesh(b,a)};Object.defineProperty(c.prototype,"material",{get:function(){return this._mesh.material},set:function(a){this._mesh.material=a}});Object.assign(c.prototype,{render:function(b){b.render(this._mesh,a)}});return c}();THREE.RenderPass=function(a,b,c,d,e){THREE.Pass.call(this);this.scene=a;this.camera=b;this.overrideMaterial=c;this.clearColor=d;this.clearAlpha=void 0!==e?e:0;this.clear=!0;this.needsSwap=this.clearDepth=!1};THREE.RenderPass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.RenderPass,render:function(a,b,c,d,e){b=a.autoClear;a.autoClear=!1;this.scene.overrideMaterial=this.overrideMaterial;var f,g;this.clearColor&&(f=a.getClearColor().getHex(),g=a.getClearAlpha(),a.setClearColor(this.clearColor,this.clearAlpha));this.clearDepth&&a.clearDepth();a.setRenderTarget(this.renderToScreen?null:c);this.clear&&a.clear(a.autoClearColor,a.autoClearDepth,a.autoClearStencil);a.render(this.scene,this.camera);this.clearColor&&a.setClearColor(f,g);this.scene.overrideMaterial=null;a.autoClear=b}});THREE.MaskPass=function(a,b){THREE.Pass.call(this);this.scene=a;this.camera=b;this.clear=!0;this.inverse=this.needsSwap=!1};THREE.MaskPass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.MaskPass,render:function(a,b,c,d,e){d=a.context;e=a.state;e.buffers.color.setMask(!1);e.buffers.depth.setMask(!1);e.buffers.color.setLocked(!0);e.buffers.depth.setLocked(!0);var f,g;this.inverse?(f=0,g=1):(f=1,g=0);e.buffers.stencil.setTest(!0);e.buffers.stencil.setOp(d.REPLACE,d.REPLACE,d.REPLACE);e.buffers.stencil.setFunc(d.ALWAYS,f,4294967295);e.buffers.stencil.setClear(g);a.setRenderTarget(c);this.clear&&a.clear();a.render(this.scene,this.camera);a.setRenderTarget(b);this.clear&&a.clear();a.render(this.scene,this.camera);e.buffers.color.setLocked(!1);e.buffers.depth.setLocked(!1);e.buffers.stencil.setFunc(d.EQUAL,1,4294967295);e.buffers.stencil.setOp(d.KEEP,d.KEEP,d.KEEP)}});THREE.ClearMaskPass=function(){THREE.Pass.call(this);this.needsSwap=!1};THREE.ClearMaskPass.prototype=Object.create(THREE.Pass.prototype);Object.assign(THREE.ClearMaskPass.prototype,{render:function(a,b,c,d,e){a.state.buffers.stencil.setTest(!1)}});THREE.ShaderPass=function(a,b){THREE.Pass.call(this);this.textureID=void 0!==b?b:"tDiffuse";a instanceof THREE.ShaderMaterial?(this.uniforms=a.uniforms,this.material=a):a&&(this.uniforms=THREE.UniformsUtils.clone(a.uniforms),this.material=new THREE.ShaderMaterial({defines:Object.assign({},a.defines),uniforms:this.uniforms,vertexShader:a.vertexShader,fragmentShader:a.fragmentShader}));this.fsQuad=new THREE.Pass.FullScreenQuad(this.material)};THREE.ShaderPass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.ShaderPass,render:function(a,b,c,d,e){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=c.texture);this.fsQuad.material=this.material;this.renderToScreen?a.setRenderTarget(null):(a.setRenderTarget(b),this.clear&&a.clear(a.autoClearColor,a.autoClearDepth,a.autoClearStencil));this.fsQuad.render(a)}});THREE.CopyShader={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv \x3d uv;\ngl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform float opacity;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel \x3d texture2D( tDiffuse, vUv );\ngl_FragColor \x3d opacity * texel;\n}"};THREE.FXAAShader={uniforms:{tDiffuse:{value:null},resolution:{value:new THREE.Vector2(1/1024,1/512)}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv \x3d uv;\ngl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:'precision highp float;\n\nuniform sampler2D tDiffuse;\n\nuniform vec2 resolution;\n\nvarying vec2 vUv;\n\n// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n\n//----------------------------------------------------------------------------------\n// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag\n// SDK Version: v3.00\n// Email:       gameworks@nvidia.com\n// Site:        http://developer.nvidia.com/\n//\n// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n//  * Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//  * Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n//  * Neither the name of NVIDIA CORPORATION nor the names of its\n//    contributors may be used to endorse or promote products derived\n//    from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS\'\' AND ANY\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//----------------------------------------------------------------------------------\n\n#define FXAA_PC 1\n#define FXAA_GLSL_100 1\n#define FXAA_QUALITY_PRESET 12\n\n#define FXAA_GREEN_AS_LUMA 1\n\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_PC_CONSOLE\n    //\n    // The console algorithm for PC is included\n    // for developers targeting really low spec machines.\n    // Likely better to just run FXAA_PC, and use a really low preset.\n    //\n    #define FXAA_PC_CONSOLE 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GLSL_120\n    #define FXAA_GLSL_120 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GLSL_130\n    #define FXAA_GLSL_130 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_HLSL_3\n    #define FXAA_HLSL_3 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_HLSL_4\n    #define FXAA_HLSL_4 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_HLSL_5\n    #define FXAA_HLSL_5 0\n#endif\n/*\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d*/\n#ifndef FXAA_GREEN_AS_LUMA\n    //\n    // For those using non-linear color,\n    // and either not able to get luma in alpha, or not wanting to,\n    // this enables FXAA to run using green as a proxy for luma.\n    // So with this enabled, no need to pack luma in alpha.\n    //\n    // This will turn off AA on anything which lacks some amount of green.\n    // Pure red and blue or combination of only R and B, will get no AA.\n    //\n    // Might want to lower the settings for both,\n    //    fxaaConsoleEdgeThresholdMin\n    //    fxaaQualityEdgeThresholdMin\n    // In order to insure AA does not get turned off on colors\n    // which contain a minor amount of green.\n    //\n    // 1 \x3d On.\n    // 0 \x3d Off.\n    //\n    #define FXAA_GREEN_AS_LUMA 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_EARLY_EXIT\n    //\n    // Controls algorithm\'s early exit path.\n    // On PS3 turning this ON adds 2 cycles to the shader.\n    // On 360 turning this OFF adds 10ths of a millisecond to the shader.\n    // Turning this off on console will result in a more blurry image.\n    // So this defaults to on.\n    //\n    // 1 \x3d On.\n    // 0 \x3d Off.\n    //\n    #define FXAA_EARLY_EXIT 1\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_DISCARD\n    //\n    // Only valid for PC OpenGL currently.\n    // Probably will not work when FXAA_GREEN_AS_LUMA \x3d 1.\n    //\n    // 1 \x3d Use discard on pixels which don\'t need AA.\n    //     For APIs which enable concurrent TEX+ROP from same surface.\n    // 0 \x3d Return unchanged color on pixels which don\'t need AA.\n    //\n    #define FXAA_DISCARD 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_FAST_PIXEL_OFFSET\n    //\n    // Used for GLSL 120 only.\n    //\n    // 1 \x3d GL API supports fast pixel offsets\n    // 0 \x3d do not use fast pixel offsets\n    //\n    #ifdef GL_EXT_gpu_shader4\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifdef GL_NV_gpu_shader5\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifdef GL_ARB_gpu_shader5\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifndef FXAA_FAST_PIXEL_OFFSET\n        #define FXAA_FAST_PIXEL_OFFSET 0\n    #endif\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GATHER4_ALPHA\n    //\n    // 1 \x3d API supports gather4 on alpha channel.\n    // 0 \x3d API does not support gather4 on alpha channel.\n    //\n    #if (FXAA_HLSL_5 \x3d\x3d 1)\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifdef GL_ARB_gpu_shader5\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifdef GL_NV_gpu_shader5\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifndef FXAA_GATHER4_ALPHA\n        #define FXAA_GATHER4_ALPHA 0\n    #endif\n#endif\n\n\n/*\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n                        FXAA QUALITY - TUNING KNOBS\n------------------------------------------------------------------------------\nNOTE the other tuning knobs are now in the shader function inputs!\n\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d*/\n#ifndef FXAA_QUALITY_PRESET\n    //\n    // Choose the quality preset.\n    // This needs to be compiled into the shader as it effects code.\n    // Best option to include multiple presets is to\n    // in each shader define the preset, then include this file.\n    //\n    // OPTIONS\n    // -----------------------------------------------------------------------\n    // 10 to 15 - default medium dither (10\x3dfastest, 15\x3dhighest quality)\n    // 20 to 29 - less dither, more expensive (20\x3dfastest, 29\x3dhighest quality)\n    // 39       - no dither, very expensive\n    //\n    // NOTES\n    // -----------------------------------------------------------------------\n    // 12 \x3d slightly faster then FXAA 3.9 and higher edge quality (default)\n    // 13 \x3d about same speed as FXAA 3.9 and better than 12\n    // 23 \x3d closest to FXAA 3.9 visually and performance wise\n    //  _ \x3d the lowest digit is directly related to performance\n    // _  \x3d the highest digit is directly related to style\n    //\n    #define FXAA_QUALITY_PRESET 12\n#endif\n\n\n/*\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n\n                           FXAA QUALITY - PRESETS\n\n\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d*/\n\n/*\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n                     FXAA QUALITY - MEDIUM DITHER PRESETS\n\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d*/\n#if (FXAA_QUALITY_PRESET \x3d\x3d 10)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 3.0\n    #define FXAA_QUALITY_P2 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET \x3d\x3d 11)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 3.0\n    #define FXAA_QUALITY_P3 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET \x3d\x3d 12)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 4.0\n    #define FXAA_QUALITY_P4 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET \x3d\x3d 13)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 4.0\n    #define FXAA_QUALITY_P5 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET \x3d\x3d 14)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 4.0\n    #define FXAA_QUALITY_P6 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET \x3d\x3d 15)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 12.0\n#endif\n\n/*\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n                     FXAA QUALITY - LOW DITHER PRESETS\n\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d*/\n#if (FXAA_QUALITY_PRESET \x3d\x3d 20)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 2.0\n    #define FXAA_QUALITY_P2 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET \x3d\x3d 21)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET \x3d\x3d 22)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET \x3d\x3d 23)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET \x3d\x3d 24)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 3.0\n    #define FXAA_QUALITY_P6 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET \x3d\x3d 25)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET \x3d\x3d 26)\n    #define FXAA_QUALITY_PS 9\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 4.0\n    #define FXAA_QUALITY_P8 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET \x3d\x3d 27)\n    #define FXAA_QUALITY_PS 10\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 4.0\n    #define FXAA_QUALITY_P9 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET \x3d\x3d 28)\n    #define FXAA_QUALITY_PS 11\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 4.0\n    #define FXAA_QUALITY_P10 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET \x3d\x3d 29)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n\n/*\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n                     FXAA QUALITY - EXTREME QUALITY\n\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d*/\n#if (FXAA_QUALITY_PRESET \x3d\x3d 39)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.0\n    #define FXAA_QUALITY_P2 1.0\n    #define FXAA_QUALITY_P3 1.0\n    #define FXAA_QUALITY_P4 1.0\n    #define FXAA_QUALITY_P5 1.5\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n\n\n\n/*\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n\n                                API PORTING\n\n\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d*/\n#if (FXAA_GLSL_100 \x3d\x3d 1) || (FXAA_GLSL_120 \x3d\x3d 1) || (FXAA_GLSL_130 \x3d\x3d 1)\n    #define FxaaBool bool\n    #define FxaaDiscard discard\n    #define FxaaFloat float\n    #define FxaaFloat2 vec2\n    #define FxaaFloat3 vec3\n    #define FxaaFloat4 vec4\n    #define FxaaHalf float\n    #define FxaaHalf2 vec2\n    #define FxaaHalf3 vec3\n    #define FxaaHalf4 vec4\n    #define FxaaInt2 ivec2\n    #define FxaaSat(x) clamp(x, 0.0, 1.0)\n    #define FxaaTex sampler2D\n#else\n    #define FxaaBool bool\n    #define FxaaDiscard clip(-1)\n    #define FxaaFloat float\n    #define FxaaFloat2 float2\n    #define FxaaFloat3 float3\n    #define FxaaFloat4 float4\n    #define FxaaHalf half\n    #define FxaaHalf2 half2\n    #define FxaaHalf3 half3\n    #define FxaaHalf4 half4\n    #define FxaaSat(x) saturate(x)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_100 \x3d\x3d 1)\n  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)\n  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_120 \x3d\x3d 1)\n    // Requires,\n    //  #version 120\n    // And at least,\n    //  #extension GL_EXT_gpu_shader4 : enable\n    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n    #if (FXAA_FAST_PIXEL_OFFSET \x3d\x3d 1)\n        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n    #else\n        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n    #endif\n    #if (FXAA_GATHER4_ALPHA \x3d\x3d 1)\n        // use #extension GL_ARB_gpu_shader5 : enable\n        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n    #endif\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_130 \x3d\x3d 1)\n    // Requires "#version 130" or better\n    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n    #if (FXAA_GATHER4_ALPHA \x3d\x3d 1)\n        // use #extension GL_ARB_gpu_shader5 : enable\n        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n    #endif\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_HLSL_3 \x3d\x3d 1)\n    #define FxaaInt2 float2\n    #define FxaaTex sampler2D\n    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_HLSL_4 \x3d\x3d 1)\n    #define FxaaInt2 int2\n    struct FxaaTex { SamplerState smpl; Texture2D tex; };\n    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_HLSL_5 \x3d\x3d 1)\n    #define FxaaInt2 int2\n    struct FxaaTex { SamplerState smpl; Texture2D tex; };\n    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n#endif\n\n\n/*\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n                   GREEN AS LUMA OPTION SUPPORT FUNCTION\n\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d*/\n#if (FXAA_GREEN_AS_LUMA \x3d\x3d 0)\n    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n#else\n    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n#endif\n\n\n\n\n/*\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\n\n                             FXAA3 QUALITY - PC\n\n\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d*/\n#if (FXAA_PC \x3d\x3d 1)\n/*--------------------------------------------------------------------------*/\nFxaaFloat4 FxaaPixelShader(\n    //\n    // Use noperspective interpolation here (turn off perspective interpolation).\n    // {xy} \x3d center of pixel\n    FxaaFloat2 pos,\n    //\n    // Used only for FXAA Console, and not used on the 360 version.\n    // Use noperspective interpolation here (turn off perspective interpolation).\n    // {xy_} \x3d upper left of pixel\n    // {_zw} \x3d lower right of pixel\n    FxaaFloat4 fxaaConsolePosPos,\n    //\n    // Input color texture.\n    // {rgb_} \x3d color in linear or perceptual color space\n    // if (FXAA_GREEN_AS_LUMA \x3d\x3d 0)\n    //     {__a} \x3d luma in perceptual color space (not linear)\n    FxaaTex tex,\n    //\n    // Only used on the optimized 360 version of FXAA Console.\n    // For everything but 360, just use the same input here as for "tex".\n    // For 360, same texture, just alias with a 2nd sampler.\n    // This sampler needs to have an exponent bias of -1.\n    FxaaTex fxaaConsole360TexExpBiasNegOne,\n    //\n    // Only used on the optimized 360 version of FXAA Console.\n    // For everything but 360, just use the same input here as for "tex".\n    // For 360, same texture, just alias with a 3nd sampler.\n    // This sampler needs to have an exponent bias of -2.\n    FxaaTex fxaaConsole360TexExpBiasNegTwo,\n    //\n    // Only used on FXAA Quality.\n    // This must be from a constant/uniform.\n    // {x_} \x3d 1.0/screenWidthInPixels\n    // {_y} \x3d 1.0/screenHeightInPixels\n    FxaaFloat2 fxaaQualityRcpFrame,\n    //\n    // Only used on FXAA Console.\n    // This must be from a constant/uniform.\n    // This effects sub-pixel AA quality and inversely sharpness.\n    //   Where N ranges between,\n    //     N \x3d 0.50 (default)\n    //     N \x3d 0.33 (sharper)\n    // {x__} \x3d -N/screenWidthInPixels\n    // {_y_} \x3d -N/screenHeightInPixels\n    // {_z_} \x3d  N/screenWidthInPixels\n    // {__w} \x3d  N/screenHeightInPixels\n    FxaaFloat4 fxaaConsoleRcpFrameOpt,\n    //\n    // Only used on FXAA Console.\n    // Not used on 360, but used on PS3 and PC.\n    // This must be from a constant/uniform.\n    // {x__} \x3d -2.0/screenWidthInPixels\n    // {_y_} \x3d -2.0/screenHeightInPixels\n    // {_z_} \x3d  2.0/screenWidthInPixels\n    // {__w} \x3d  2.0/screenHeightInPixels\n    FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n    //\n    // Only used on FXAA Console.\n    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\n    // This must be from a constant/uniform.\n    // {x__} \x3d  8.0/screenWidthInPixels\n    // {_y_} \x3d  8.0/screenHeightInPixels\n    // {_z_} \x3d -4.0/screenWidthInPixels\n    // {__w} \x3d -4.0/screenHeightInPixels\n    FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_SUBPIX define.\n    // It is here now to allow easier tuning.\n    // Choose the amount of sub-pixel aliasing removal.\n    // This can effect sharpness.\n    //   1.00 - upper limit (softer)\n    //   0.75 - default amount of filtering\n    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n    //   0.25 - almost off\n    //   0.00 - completely off\n    FxaaFloat fxaaQualitySubpix,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n    // It is here now to allow easier tuning.\n    // The minimum amount of local contrast required to apply algorithm.\n    //   0.333 - too little (faster)\n    //   0.250 - low quality\n    //   0.166 - default\n    //   0.125 - high quality\n    //   0.063 - overkill (slower)\n    FxaaFloat fxaaQualityEdgeThreshold,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n    // It is here now to allow easier tuning.\n    // Trims the algorithm from processing darks.\n    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n    //   0.0625 - high quality (faster)\n    //   0.0312 - visible limit (slower)\n    // Special notes when using FXAA_GREEN_AS_LUMA,\n    //   Likely want to set this to zero.\n    //   As colors that are mostly not-green\n    //   will appear very dark in the green channel!\n    //   Tune by looking at mostly non-green content,\n    //   then start at zero and increase until aliasing is a problem.\n    FxaaFloat fxaaQualityEdgeThresholdMin,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\n    // It is here now to allow easier tuning.\n    // This does not effect PS3, as this needs to be compiled in.\n    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\n    //   Due to the PS3 being ALU bound,\n    //   there are only THREE safe values here: 2 and 4 and 8.\n    //   These options use the shaders ability to a free *|/ by 2|4|8.\n    // For all other platforms can be a non-power of two.\n    //   8.0 is sharper (default!!!)\n    //   4.0 is softer\n    //   2.0 is really soft (good only for vector graphics inputs)\n    FxaaFloat fxaaConsoleEdgeSharpness,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\n    // It is here now to allow easier tuning.\n    // This does not effect PS3, as this needs to be compiled in.\n    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\n    //   Due to the PS3 being ALU bound,\n    //   there are only two safe values here: 1/4 and 1/8.\n    //   These options use the shaders ability to a free *|/ by 2|4|8.\n    // The console setting has a different mapping than the quality setting.\n    // Other platforms can use other values.\n    //   0.125 leaves less aliasing, but is softer (default!!!)\n    //   0.25 leaves more aliasing, and is sharper\n    FxaaFloat fxaaConsoleEdgeThreshold,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\n    // It is here now to allow easier tuning.\n    // Trims the algorithm from processing darks.\n    // The console setting has a different mapping than the quality setting.\n    // This only applies when FXAA_EARLY_EXIT is 1.\n    // This does not apply to PS3,\n    // PS3 was simplified to avoid more shader instructions.\n    //   0.06 - faster but more aliasing in darks\n    //   0.05 - default\n    //   0.04 - slower and less aliasing in darks\n    // Special notes when using FXAA_GREEN_AS_LUMA,\n    //   Likely want to set this to zero.\n    //   As colors that are mostly not-green\n    //   will appear very dark in the green channel!\n    //   Tune by looking at mostly non-green content,\n    //   then start at zero and increase until aliasing is a problem.\n    FxaaFloat fxaaConsoleEdgeThresholdMin,\n    //\n    // Extra constants for 360 FXAA Console only.\n    // Use zeros or anything else for other platforms.\n    // These must be in physical constant registers and NOT immediates.\n    // Immediates will result in compiler un-optimizing.\n    // {xyzw} \x3d float4(1.0, -1.0, 0.25, -0.25)\n    FxaaFloat4 fxaaConsole360ConstDir\n) {\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posM;\n    posM.x \x3d pos.x;\n    posM.y \x3d pos.y;\n    #if (FXAA_GATHER4_ALPHA \x3d\x3d 1)\n        #if (FXAA_DISCARD \x3d\x3d 0)\n            FxaaFloat4 rgbyM \x3d FxaaTexTop(tex, posM);\n            #if (FXAA_GREEN_AS_LUMA \x3d\x3d 0)\n                #define lumaM rgbyM.w\n            #else\n                #define lumaM rgbyM.y\n            #endif\n        #endif\n        #if (FXAA_GREEN_AS_LUMA \x3d\x3d 0)\n            FxaaFloat4 luma4A \x3d FxaaTexAlpha4(tex, posM);\n            FxaaFloat4 luma4B \x3d FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n        #else\n            FxaaFloat4 luma4A \x3d FxaaTexGreen4(tex, posM);\n            FxaaFloat4 luma4B \x3d FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n        #endif\n        #if (FXAA_DISCARD \x3d\x3d 1)\n            #define lumaM luma4A.w\n        #endif\n        #define lumaE luma4A.z\n        #define lumaS luma4A.x\n        #define lumaSE luma4A.y\n        #define lumaNW luma4B.w\n        #define lumaN luma4B.z\n        #define lumaW luma4B.x\n    #else\n        FxaaFloat4 rgbyM \x3d FxaaTexTop(tex, posM);\n        #if (FXAA_GREEN_AS_LUMA \x3d\x3d 0)\n            #define lumaM rgbyM.w\n        #else\n            #define lumaM rgbyM.y\n        #endif\n        #if (FXAA_GLSL_100 \x3d\x3d 1)\n          FxaaFloat lumaS \x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaE \x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaN \x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaW \x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n        #else\n          FxaaFloat lumaS \x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaE \x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaN \x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaW \x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n        #endif\n    #endif\n/*--------------------------------------------------------------------------*/\n    FxaaFloat maxSM \x3d max(lumaS, lumaM);\n    FxaaFloat minSM \x3d min(lumaS, lumaM);\n    FxaaFloat maxESM \x3d max(lumaE, maxSM);\n    FxaaFloat minESM \x3d min(lumaE, minSM);\n    FxaaFloat maxWN \x3d max(lumaN, lumaW);\n    FxaaFloat minWN \x3d min(lumaN, lumaW);\n    FxaaFloat rangeMax \x3d max(maxWN, maxESM);\n    FxaaFloat rangeMin \x3d min(minWN, minESM);\n    FxaaFloat rangeMaxScaled \x3d rangeMax * fxaaQualityEdgeThreshold;\n    FxaaFloat range \x3d rangeMax - rangeMin;\n    FxaaFloat rangeMaxClamped \x3d max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n    FxaaBool earlyExit \x3d range \x3c rangeMaxClamped;\n/*--------------------------------------------------------------------------*/\n    if(earlyExit)\n        #if (FXAA_DISCARD \x3d\x3d 1)\n            FxaaDiscard;\n        #else\n            return rgbyM;\n        #endif\n/*--------------------------------------------------------------------------*/\n    #if (FXAA_GATHER4_ALPHA \x3d\x3d 0)\n        #if (FXAA_GLSL_100 \x3d\x3d 1)\n          FxaaFloat lumaNW \x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSE \x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaNE \x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSW \x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n        #else\n          FxaaFloat lumaNW \x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSE \x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaNE \x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSW \x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n        #endif\n    #else\n        FxaaFloat lumaNE \x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaSW \x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n    #endif\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNS \x3d lumaN + lumaS;\n    FxaaFloat lumaWE \x3d lumaW + lumaE;\n    FxaaFloat subpixRcpRange \x3d 1.0/range;\n    FxaaFloat subpixNSWE \x3d lumaNS + lumaWE;\n    FxaaFloat edgeHorz1 \x3d (-2.0 * lumaM) + lumaNS;\n    FxaaFloat edgeVert1 \x3d (-2.0 * lumaM) + lumaWE;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNESE \x3d lumaNE + lumaSE;\n    FxaaFloat lumaNWNE \x3d lumaNW + lumaNE;\n    FxaaFloat edgeHorz2 \x3d (-2.0 * lumaE) + lumaNESE;\n    FxaaFloat edgeVert2 \x3d (-2.0 * lumaN) + lumaNWNE;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNWSW \x3d lumaNW + lumaSW;\n    FxaaFloat lumaSWSE \x3d lumaSW + lumaSE;\n    FxaaFloat edgeHorz4 \x3d (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n    FxaaFloat edgeVert4 \x3d (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n    FxaaFloat edgeHorz3 \x3d (-2.0 * lumaW) + lumaNWSW;\n    FxaaFloat edgeVert3 \x3d (-2.0 * lumaS) + lumaSWSE;\n    FxaaFloat edgeHorz \x3d abs(edgeHorz3) + edgeHorz4;\n    FxaaFloat edgeVert \x3d abs(edgeVert3) + edgeVert4;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat subpixNWSWNESE \x3d lumaNWSW + lumaNESE;\n    FxaaFloat lengthSign \x3d fxaaQualityRcpFrame.x;\n    FxaaBool horzSpan \x3d edgeHorz \x3e\x3d edgeVert;\n    FxaaFloat subpixA \x3d subpixNSWE * 2.0 + subpixNWSWNESE;\n/*--------------------------------------------------------------------------*/\n    if(!horzSpan) lumaN \x3d lumaW;\n    if(!horzSpan) lumaS \x3d lumaE;\n    if(horzSpan) lengthSign \x3d fxaaQualityRcpFrame.y;\n    FxaaFloat subpixB \x3d (subpixA * (1.0/12.0)) - lumaM;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat gradientN \x3d lumaN - lumaM;\n    FxaaFloat gradientS \x3d lumaS - lumaM;\n    FxaaFloat lumaNN \x3d lumaN + lumaM;\n    FxaaFloat lumaSS \x3d lumaS + lumaM;\n    FxaaBool pairN \x3d abs(gradientN) \x3e\x3d abs(gradientS);\n    FxaaFloat gradient \x3d max(abs(gradientN), abs(gradientS));\n    if(pairN) lengthSign \x3d -lengthSign;\n    FxaaFloat subpixC \x3d FxaaSat(abs(subpixB) * subpixRcpRange);\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posB;\n    posB.x \x3d posM.x;\n    posB.y \x3d posM.y;\n    FxaaFloat2 offNP;\n    offNP.x \x3d (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n    offNP.y \x3d ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n    if(!horzSpan) posB.x +\x3d lengthSign * 0.5;\n    if( horzSpan) posB.y +\x3d lengthSign * 0.5;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posN;\n    posN.x \x3d posB.x - offNP.x * FXAA_QUALITY_P0;\n    posN.y \x3d posB.y - offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat2 posP;\n    posP.x \x3d posB.x + offNP.x * FXAA_QUALITY_P0;\n    posP.y \x3d posB.y + offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat subpixD \x3d ((-2.0)*subpixC) + 3.0;\n    FxaaFloat lumaEndN \x3d FxaaLuma(FxaaTexTop(tex, posN));\n    FxaaFloat subpixE \x3d subpixC * subpixC;\n    FxaaFloat lumaEndP \x3d FxaaLuma(FxaaTexTop(tex, posP));\n/*--------------------------------------------------------------------------*/\n    if(!pairN) lumaNN \x3d lumaSS;\n    FxaaFloat gradientScaled \x3d gradient * 1.0/4.0;\n    FxaaFloat lumaMM \x3d lumaM - lumaNN * 0.5;\n    FxaaFloat subpixF \x3d subpixD * subpixE;\n    FxaaBool lumaMLTZero \x3d lumaMM \x3c 0.0;\n/*--------------------------------------------------------------------------*/\n    lumaEndN -\x3d lumaNN * 0.5;\n    lumaEndP -\x3d lumaNN * 0.5;\n    FxaaBool doneN \x3d abs(lumaEndN) \x3e\x3d gradientScaled;\n    FxaaBool doneP \x3d abs(lumaEndP) \x3e\x3d gradientScaled;\n    if(!doneN) posN.x -\x3d offNP.x * FXAA_QUALITY_P1;\n    if(!doneN) posN.y -\x3d offNP.y * FXAA_QUALITY_P1;\n    FxaaBool doneNP \x3d (!doneN) || (!doneP);\n    if(!doneP) posP.x +\x3d offNP.x * FXAA_QUALITY_P1;\n    if(!doneP) posP.y +\x3d offNP.y * FXAA_QUALITY_P1;\n/*--------------------------------------------------------------------------*/\n    if(doneNP) {\n        if(!doneN) lumaEndN \x3d FxaaLuma(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP \x3d FxaaLuma(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN \x3d lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP \x3d lumaEndP - lumaNN * 0.5;\n        doneN \x3d abs(lumaEndN) \x3e\x3d gradientScaled;\n        doneP \x3d abs(lumaEndP) \x3e\x3d gradientScaled;\n        if(!doneN) posN.x -\x3d offNP.x * FXAA_QUALITY_P2;\n        if(!doneN) posN.y -\x3d offNP.y * FXAA_QUALITY_P2;\n        doneNP \x3d (!doneN) || (!doneP);\n        if(!doneP) posP.x +\x3d offNP.x * FXAA_QUALITY_P2;\n        if(!doneP) posP.y +\x3d offNP.y * FXAA_QUALITY_P2;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS \x3e 3)\n        if(doneNP) {\n            if(!doneN) lumaEndN \x3d FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP \x3d FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN \x3d lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP \x3d lumaEndP - lumaNN * 0.5;\n            doneN \x3d abs(lumaEndN) \x3e\x3d gradientScaled;\n            doneP \x3d abs(lumaEndP) \x3e\x3d gradientScaled;\n            if(!doneN) posN.x -\x3d offNP.x * FXAA_QUALITY_P3;\n            if(!doneN) posN.y -\x3d offNP.y * FXAA_QUALITY_P3;\n            doneNP \x3d (!doneN) || (!doneP);\n            if(!doneP) posP.x +\x3d offNP.x * FXAA_QUALITY_P3;\n            if(!doneP) posP.y +\x3d offNP.y * FXAA_QUALITY_P3;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS \x3e 4)\n            if(doneNP) {\n                if(!doneN) lumaEndN \x3d FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP \x3d FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN \x3d lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP \x3d lumaEndP - lumaNN * 0.5;\n                doneN \x3d abs(lumaEndN) \x3e\x3d gradientScaled;\n                doneP \x3d abs(lumaEndP) \x3e\x3d gradientScaled;\n                if(!doneN) posN.x -\x3d offNP.x * FXAA_QUALITY_P4;\n                if(!doneN) posN.y -\x3d offNP.y * FXAA_QUALITY_P4;\n                doneNP \x3d (!doneN) || (!doneP);\n                if(!doneP) posP.x +\x3d offNP.x * FXAA_QUALITY_P4;\n                if(!doneP) posP.y +\x3d offNP.y * FXAA_QUALITY_P4;\n/*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS \x3e 5)\n                if(doneNP) {\n                    if(!doneN) lumaEndN \x3d FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP \x3d FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN \x3d lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP \x3d lumaEndP - lumaNN * 0.5;\n                    doneN \x3d abs(lumaEndN) \x3e\x3d gradientScaled;\n                    doneP \x3d abs(lumaEndP) \x3e\x3d gradientScaled;\n                    if(!doneN) posN.x -\x3d offNP.x * FXAA_QUALITY_P5;\n                    if(!doneN) posN.y -\x3d offNP.y * FXAA_QUALITY_P5;\n                    doneNP \x3d (!doneN) || (!doneP);\n                    if(!doneP) posP.x +\x3d offNP.x * FXAA_QUALITY_P5;\n                    if(!doneP) posP.y +\x3d offNP.y * FXAA_QUALITY_P5;\n/*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS \x3e 6)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN \x3d FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP \x3d FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN \x3d lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP \x3d lumaEndP - lumaNN * 0.5;\n                        doneN \x3d abs(lumaEndN) \x3e\x3d gradientScaled;\n                        doneP \x3d abs(lumaEndP) \x3e\x3d gradientScaled;\n                        if(!doneN) posN.x -\x3d offNP.x * FXAA_QUALITY_P6;\n                        if(!doneN) posN.y -\x3d offNP.y * FXAA_QUALITY_P6;\n                        doneNP \x3d (!doneN) || (!doneP);\n                        if(!doneP) posP.x +\x3d offNP.x * FXAA_QUALITY_P6;\n                        if(!doneP) posP.y +\x3d offNP.y * FXAA_QUALITY_P6;\n/*--------------------------------------------------------------------------*/\n                        #if (FXAA_QUALITY_PS \x3e 7)\n                        if(doneNP) {\n                            if(!doneN) lumaEndN \x3d FxaaLuma(FxaaTexTop(tex, posN.xy));\n                            if(!doneP) lumaEndP \x3d FxaaLuma(FxaaTexTop(tex, posP.xy));\n                            if(!doneN) lumaEndN \x3d lumaEndN - lumaNN * 0.5;\n                            if(!doneP) lumaEndP \x3d lumaEndP - lumaNN * 0.5;\n                            doneN \x3d abs(lumaEndN) \x3e\x3d gradientScaled;\n                            doneP \x3d abs(lumaEndP) \x3e\x3d gradientScaled;\n                            if(!doneN) posN.x -\x3d offNP.x * FXAA_QUALITY_P7;\n                            if(!doneN) posN.y -\x3d offNP.y * FXAA_QUALITY_P7;\n                            doneNP \x3d (!doneN) || (!doneP);\n                            if(!doneP) posP.x +\x3d offNP.x * FXAA_QUALITY_P7;\n                            if(!doneP) posP.y +\x3d offNP.y * FXAA_QUALITY_P7;\n/*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PS \x3e 8)\n    if(doneNP) {\n        if(!doneN) lumaEndN \x3d FxaaLuma(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP \x3d FxaaLuma(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN \x3d lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP \x3d lumaEndP - lumaNN * 0.5;\n        doneN \x3d abs(lumaEndN) \x3e\x3d gradientScaled;\n        doneP \x3d abs(lumaEndP) \x3e\x3d gradientScaled;\n        if(!doneN) posN.x -\x3d offNP.x * FXAA_QUALITY_P8;\n        if(!doneN) posN.y -\x3d offNP.y * FXAA_QUALITY_P8;\n        doneNP \x3d (!doneN) || (!doneP);\n        if(!doneP) posP.x +\x3d offNP.x * FXAA_QUALITY_P8;\n        if(!doneP) posP.y +\x3d offNP.y * FXAA_QUALITY_P8;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS \x3e 9)\n        if(doneNP) {\n            if(!doneN) lumaEndN \x3d FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP \x3d FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN \x3d lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP \x3d lumaEndP - lumaNN * 0.5;\n            doneN \x3d abs(lumaEndN) \x3e\x3d gradientScaled;\n            doneP \x3d abs(lumaEndP) \x3e\x3d gradientScaled;\n            if(!doneN) posN.x -\x3d offNP.x * FXAA_QUALITY_P9;\n            if(!doneN) posN.y -\x3d offNP.y * FXAA_QUALITY_P9;\n            doneNP \x3d (!doneN) || (!doneP);\n            if(!doneP) posP.x +\x3d offNP.x * FXAA_QUALITY_P9;\n            if(!doneP) posP.y +\x3d offNP.y * FXAA_QUALITY_P9;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS \x3e 10)\n            if(doneNP) {\n                if(!doneN) lumaEndN \x3d FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP \x3d FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN \x3d lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP \x3d lumaEndP - lumaNN * 0.5;\n                doneN \x3d abs(lumaEndN) \x3e\x3d gradientScaled;\n                doneP \x3d abs(lumaEndP) \x3e\x3d gradientScaled;\n                if(!doneN) posN.x -\x3d offNP.x * FXAA_QUALITY_P10;\n                if(!doneN) posN.y -\x3d offNP.y * FXAA_QUALITY_P10;\n                doneNP \x3d (!doneN) || (!doneP);\n                if(!doneP) posP.x +\x3d offNP.x * FXAA_QUALITY_P10;\n                if(!doneP) posP.y +\x3d offNP.y * FXAA_QUALITY_P10;\n/*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS \x3e 11)\n                if(doneNP) {\n                    if(!doneN) lumaEndN \x3d FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP \x3d FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN \x3d lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP \x3d lumaEndP - lumaNN * 0.5;\n                    doneN \x3d abs(lumaEndN) \x3e\x3d gradientScaled;\n                    doneP \x3d abs(lumaEndP) \x3e\x3d gradientScaled;\n                    if(!doneN) posN.x -\x3d offNP.x * FXAA_QUALITY_P11;\n                    if(!doneN) posN.y -\x3d offNP.y * FXAA_QUALITY_P11;\n                    doneNP \x3d (!doneN) || (!doneP);\n                    if(!doneP) posP.x +\x3d offNP.x * FXAA_QUALITY_P11;\n                    if(!doneP) posP.y +\x3d offNP.y * FXAA_QUALITY_P11;\n/*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS \x3e 12)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN \x3d FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP \x3d FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN \x3d lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP \x3d lumaEndP - lumaNN * 0.5;\n                        doneN \x3d abs(lumaEndN) \x3e\x3d gradientScaled;\n                        doneP \x3d abs(lumaEndP) \x3e\x3d gradientScaled;\n                        if(!doneN) posN.x -\x3d offNP.x * FXAA_QUALITY_P12;\n                        if(!doneN) posN.y -\x3d offNP.y * FXAA_QUALITY_P12;\n                        doneNP \x3d (!doneN) || (!doneP);\n                        if(!doneP) posP.x +\x3d offNP.x * FXAA_QUALITY_P12;\n                        if(!doneP) posP.y +\x3d offNP.y * FXAA_QUALITY_P12;\n/*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n/*--------------------------------------------------------------------------*/\n                }\n                #endif\n/*--------------------------------------------------------------------------*/\n            }\n            #endif\n/*--------------------------------------------------------------------------*/\n        }\n        #endif\n/*--------------------------------------------------------------------------*/\n    }\n    #endif\n/*--------------------------------------------------------------------------*/\n                        }\n                        #endif\n/*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n/*--------------------------------------------------------------------------*/\n                }\n                #endif\n/*--------------------------------------------------------------------------*/\n            }\n            #endif\n/*--------------------------------------------------------------------------*/\n        }\n        #endif\n/*--------------------------------------------------------------------------*/\n    }\n/*--------------------------------------------------------------------------*/\n    FxaaFloat dstN \x3d posM.x - posN.x;\n    FxaaFloat dstP \x3d posP.x - posM.x;\n    if(!horzSpan) dstN \x3d posM.y - posN.y;\n    if(!horzSpan) dstP \x3d posP.y - posM.y;\n/*--------------------------------------------------------------------------*/\n    FxaaBool goodSpanN \x3d (lumaEndN \x3c 0.0) !\x3d lumaMLTZero;\n    FxaaFloat spanLength \x3d (dstP + dstN);\n    FxaaBool goodSpanP \x3d (lumaEndP \x3c 0.0) !\x3d lumaMLTZero;\n    FxaaFloat spanLengthRcp \x3d 1.0/spanLength;\n/*--------------------------------------------------------------------------*/\n    FxaaBool directionN \x3d dstN \x3c dstP;\n    FxaaFloat dst \x3d min(dstN, dstP);\n    FxaaBool goodSpan \x3d directionN ? goodSpanN : goodSpanP;\n    FxaaFloat subpixG \x3d subpixF * subpixF;\n    FxaaFloat pixelOffset \x3d (dst * (-spanLengthRcp)) + 0.5;\n    FxaaFloat subpixH \x3d subpixG * fxaaQualitySubpix;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat pixelOffsetGood \x3d goodSpan ? pixelOffset : 0.0;\n    FxaaFloat pixelOffsetSubpix \x3d max(pixelOffsetGood, subpixH);\n    if(!horzSpan) posM.x +\x3d pixelOffsetSubpix * lengthSign;\n    if( horzSpan) posM.y +\x3d pixelOffsetSubpix * lengthSign;\n    #if (FXAA_DISCARD \x3d\x3d 1)\n        return FxaaTexTop(tex, posM);\n    #else\n        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n    #endif\n}\n/*\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d*/\n#endif\n\nvoid main() {\n  gl_FragColor \x3d FxaaPixelShader(\n    vUv,\n    vec4(0.0),\n    tDiffuse,\n    tDiffuse,\n    tDiffuse,\n    resolution,\n    vec4(0.0),\n    vec4(0.0),\n    vec4(0.0),\n    0.75,\n    0.166,\n    0.0833,\n    0.0,\n    0.0,\n    0.0,\n    vec4(0.0)\n  );\n\n  // TODO avoid querying texture twice for same texel\n  gl_FragColor.a \x3d texture2D(tDiffuse, vUv).a;\n}'};THREE.ConvolutionShader={defines:{KERNEL_SIZE_FLOAT:"25.0",KERNEL_SIZE_INT:"25"},uniforms:{tDiffuse:{value:null},uImageIncrement:{value:new THREE.Vector2(.001953125,0)},cKernel:{value:[]}},vertexShader:"uniform vec2 uImageIncrement;\nvarying vec2 vUv;\nvoid main() {\nvUv \x3d uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\ngl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform float cKernel[ KERNEL_SIZE_INT ];\nuniform sampler2D tDiffuse;\nuniform vec2 uImageIncrement;\nvarying vec2 vUv;\nvoid main() {\nvec2 imageCoord \x3d vUv;\nvec4 sum \x3d vec4( 0.0, 0.0, 0.0, 0.0 );\nfor( int i \x3d 0; i \x3c KERNEL_SIZE_INT; i ++ ) {\nsum +\x3d texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\nimageCoord +\x3d uImageIncrement;\n}\ngl_FragColor \x3d sum;\n}",buildKernel:function(a){var b,c,d,e,f=2*Math.ceil(3*a)+1;25<f&&(f=25);e=.5*(f-1);c=Array(f);for(b=d=0;b<f;++b){var g=b-e;c[b]=Math.exp(-(g*g)/(2*a*a));d+=c[b]}for(b=0;b<f;++b)c[b]/=d;return c}};THREE.LuminosityHighPassShader={shaderID:"luminosityHighPass",uniforms:{tDiffuse:{type:"t",value:null},luminosityThreshold:{type:"f",value:1},smoothWidth:{type:"f",value:1},defaultColor:{type:"c",value:new THREE.Color(0)},defaultOpacity:{type:"f",value:0}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv \x3d uv;\ngl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D tDiffuse;\nuniform vec3 defaultColor;\nuniform float defaultOpacity;\nuniform float luminosityThreshold;\nuniform float smoothWidth;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel \x3d texture2D( tDiffuse, vUv );\nvec3 luma \x3d vec3( 0.299, 0.587, 0.114 );\nfloat v \x3d dot( texel.xyz, luma );\nvec4 outputColor \x3d vec4( defaultColor.rgb, defaultOpacity );\nfloat alpha \x3d smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\ngl_FragColor \x3d mix( outputColor, texel, alpha );\n}"};THREE.UnrealBloomPass=function(a,b,c,d){THREE.Pass.call(this);this.strength=void 0!==b?b:1;this.radius=c;this.threshold=d;this.resolution=void 0!==a?new THREE.Vector2(a.x,a.y):new THREE.Vector2(256,256);this.clearColor=new THREE.Color(0,0,0);var e={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat};this.renderTargetsHorizontal=[];this.renderTargetsVertical=[];this.nMips=5;a=Math.round(this.resolution.x/2);c=Math.round(this.resolution.y/2);this.renderTargetBright=new THREE.WebGLRenderTarget(a,c,e);this.renderTargetBright.texture.name="UnrealBloomPass.bright";this.renderTargetBright.texture.generateMipmaps=!1;for(var f=0;f<this.nMips;f++){var g=new THREE.WebGLRenderTarget(a,c,e);g.texture.name="UnrealBloomPass.h"+f;g.texture.generateMipmaps=!1;this.renderTargetsHorizontal.push(g);g=new THREE.WebGLRenderTarget(a,c,e);g.texture.name="UnrealBloomPass.v"+f;g.texture.generateMipmaps=!1;this.renderTargetsVertical.push(g);a=Math.round(a/2);c=Math.round(c/2)}void 0===THREE.LuminosityHighPassShader&&console.error("THREE.UnrealBloomPass relies on THREE.LuminosityHighPassShader");a=THREE.LuminosityHighPassShader;this.highPassUniforms=THREE.UniformsUtils.clone(a.uniforms);this.highPassUniforms.luminosityThreshold.value=d;this.highPassUniforms.smoothWidth.value=.01;this.materialHighPassFilter=new THREE.ShaderMaterial({uniforms:this.highPassUniforms,vertexShader:a.vertexShader,fragmentShader:a.fragmentShader,defines:{}});this.separableBlurMaterials=[];d=[3,5,7,9,11];a=Math.round(this.resolution.x/2);c=Math.round(this.resolution.y/2);for(f=0;f<this.nMips;f++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(d[f])),this.separableBlurMaterials[f].uniforms.texSize.value=new THREE.Vector2(a,c),a=Math.round(a/2),c=Math.round(c/2);this.compositeMaterial=this.getCompositeMaterial(this.nMips);this.compositeMaterial.uniforms.blurTexture1.value=this.renderTargetsVertical[0].texture;this.compositeMaterial.uniforms.blurTexture2.value=this.renderTargetsVertical[1].texture;this.compositeMaterial.uniforms.blurTexture3.value=this.renderTargetsVertical[2].texture;this.compositeMaterial.uniforms.blurTexture4.value=this.renderTargetsVertical[3].texture;this.compositeMaterial.uniforms.blurTexture5.value=this.renderTargetsVertical[4].texture;this.compositeMaterial.uniforms.bloomStrength.value=b;this.compositeMaterial.uniforms.bloomRadius.value=.1;this.compositeMaterial.needsUpdate=!0;this.compositeMaterial.uniforms.bloomFactors.value=[1,.8,.6,.4,.2];this.bloomTintColors=[new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1)];this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors;void 0===THREE.CopyShader&&console.error("THREE.BloomPass relies on THREE.CopyShader");b=THREE.CopyShader;this.copyUniforms=THREE.UniformsUtils.clone(b.uniforms);this.copyUniforms.opacity.value=1;this.materialCopy=new THREE.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:b.vertexShader,fragmentShader:b.fragmentShader,blending:THREE.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0});this.enabled=!0;this.needsSwap=!1;this.oldClearColor=new THREE.Color;this.oldClearAlpha=1;this.basic=new THREE.MeshBasicMaterial;this.fsQuad=new THREE.Pass.FullScreenQuad(null)};THREE.UnrealBloomPass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.UnrealBloomPass,dispose:function(){for(var a=0;a<this.renderTargetsHorizontal.length;a++)this.renderTargetsHorizontal[a].dispose();for(a=0;a<this.renderTargetsVertical.length;a++)this.renderTargetsVertical[a].dispose();this.renderTargetBright.dispose()},setSize:function(a,b){a=Math.round(a/2);b=Math.round(b/2);this.renderTargetBright.setSize(a,b);for(var c=0;c<this.nMips;c++)this.renderTargetsHorizontal[c].setSize(a,b),this.renderTargetsVertical[c].setSize(a,b),this.separableBlurMaterials[c].uniforms.texSize.value=new THREE.Vector2(a,b),a=Math.round(a/2),b=Math.round(b/2)},render:function(a,b,c,d,e){this.oldClearColor.copy(a.getClearColor());this.oldClearAlpha=a.getClearAlpha();b=a.autoClear;a.autoClear=!1;a.setClearColor(this.clearColor,0);e&&a.context.disable(a.context.STENCIL_TEST);this.renderToScreen&&(this.fsQuad.material=this.basic,this.basic.map=c.texture,a.setRenderTarget(null),a.clear(),this.fsQuad.render(a));this.highPassUniforms.tDiffuse.value=c.texture;this.highPassUniforms.luminosityThreshold.value=this.threshold;this.fsQuad.material=this.materialHighPassFilter;a.setRenderTarget(this.renderTargetBright);a.clear();this.fsQuad.render(a);d=this.renderTargetBright;for(var f=0;f<this.nMips;f++)this.fsQuad.material=this.separableBlurMaterials[f],this.separableBlurMaterials[f].uniforms.colorTexture.value=d.texture,this.separableBlurMaterials[f].uniforms.direction.value=THREE.UnrealBloomPass.BlurDirectionX,a.setRenderTarget(this.renderTargetsHorizontal[f]),a.clear(),this.fsQuad.render(a),this.separableBlurMaterials[f].uniforms.colorTexture.value=this.renderTargetsHorizontal[f].texture,this.separableBlurMaterials[f].uniforms.direction.value=THREE.UnrealBloomPass.BlurDirectionY,a.setRenderTarget(this.renderTargetsVertical[f]),a.clear(),this.fsQuad.render(a),d=this.renderTargetsVertical[f];this.fsQuad.material=this.compositeMaterial;this.compositeMaterial.uniforms.bloomStrength.value=this.strength;this.compositeMaterial.uniforms.bloomRadius.value=this.radius;this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors;a.setRenderTarget(this.renderTargetsHorizontal[0]);a.clear();this.fsQuad.render(a);this.fsQuad.material=this.materialCopy;this.copyUniforms.tDiffuse.value=this.renderTargetsHorizontal[0].texture;e&&a.context.enable(a.context.STENCIL_TEST);this.renderToScreen?a.setRenderTarget(null):a.setRenderTarget(c);this.fsQuad.render(a);a.setClearColor(this.oldClearColor,this.oldClearAlpha);a.autoClear=b},getSeperableBlurMaterial:function(a){return new THREE.ShaderMaterial({defines:{KERNEL_RADIUS:a,SIGMA:a},uniforms:{colorTexture:{value:null},texSize:{value:new THREE.Vector2(.5,.5)},direction:{value:new THREE.Vector2(.5,.5)}},vertexShader:"varying vec2 vUv;\n\r\n\t\t\t\tvoid main() {\n\r\n\t\t\t\t\tvUv \x3d uv;\n\r\n\t\t\t\t\tgl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\r\n\t\t\t\t}",fragmentShader:"#include \x3ccommon\x3e\r\n\t\t\t\tvarying vec2 vUv;\n\r\n\t\t\t\tuniform sampler2D colorTexture;\n\r\n\t\t\t\tuniform vec2 texSize;\r\n\t\t\t\tuniform vec2 direction;\r\n\t\t\t\t\r\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\r\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\r\n\t\t\t\t}\r\n\t\t\t\tvoid main() {\n\r\n\t\t\t\t\tvec2 invSize \x3d 1.0 / texSize;\r\n\t\t\t\t\tfloat fSigma \x3d float(SIGMA);\r\n\t\t\t\t\tfloat weightSum \x3d gaussianPdf(0.0, fSigma);\r\n\t\t\t\t\tvec3 diffuseSum \x3d texture2D( colorTexture, vUv).rgb * weightSum;\r\n\t\t\t\t\tfor( int i \x3d 1; i \x3c KERNEL_RADIUS; i ++ ) {\r\n\t\t\t\t\t\tfloat x \x3d float(i);\r\n\t\t\t\t\t\tfloat w \x3d gaussianPdf(x, fSigma);\r\n\t\t\t\t\t\tvec2 uvOffset \x3d direction * invSize * x;\r\n\t\t\t\t\t\tvec3 sample1 \x3d texture2D( colorTexture, vUv + uvOffset).rgb;\r\n\t\t\t\t\t\tvec3 sample2 \x3d texture2D( colorTexture, vUv - uvOffset).rgb;\r\n\t\t\t\t\t\tdiffuseSum +\x3d (sample1 + sample2) * w;\r\n\t\t\t\t\t\tweightSum +\x3d 2.0 * w;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgl_FragColor \x3d vec4(diffuseSum/weightSum, 1.0);\n\r\n\t\t\t\t}"})},getCompositeMaterial:function(a){return new THREE.ShaderMaterial({defines:{NUM_MIPS:a},uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},dirtTexture:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:"varying vec2 vUv;\n\r\n\t\t\t\tvoid main() {\n\r\n\t\t\t\t\tvUv \x3d uv;\n\r\n\t\t\t\t\tgl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\r\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\r\n\t\t\t\tuniform sampler2D blurTexture1;\r\n\t\t\t\tuniform sampler2D blurTexture2;\r\n\t\t\t\tuniform sampler2D blurTexture3;\r\n\t\t\t\tuniform sampler2D blurTexture4;\r\n\t\t\t\tuniform sampler2D blurTexture5;\r\n\t\t\t\tuniform sampler2D dirtTexture;\r\n\t\t\t\tuniform float bloomStrength;\r\n\t\t\t\tuniform float bloomRadius;\r\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\r\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\r\n\t\t\t\t\r\n\t\t\t\tfloat lerpBloomFactor(const in float factor) { \r\n\t\t\t\t\tfloat mirrorFactor \x3d 1.2 - factor;\r\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\tgl_FragColor \x3d bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\r\n\t\t\t\t}"})}});THREE.UnrealBloomPass.BlurDirectionX=new THREE.Vector2(1,0);THREE.UnrealBloomPass.BlurDirectionY=new THREE.Vector2(0,1);THREE.RaysShader={uniforms:{tDiffuse:{value:null}},vertexShader:"\n\n        varying vec2 vUv;\n\n        void main() {\n\n            vUv \x3d uv;\n            \n            gl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); \n            \n        }\n\n    ",fragmentShader:"\n\n        uniform sampler2D tDiffuse;\n    varying vec2 vUv;\n\n        void main() {\n\n             vec4 cTextureScreen \x3d texture2D( tDiffuse, vUv );\n            \n           vec2 custom_glFragCoord \x3d vUv;\n           vec2 position \x3d custom_glFragCoord / 2.0;\n           vec2 temp_position \x3d position;\n           vec3 accumulation \x3d vec3(0.0);\n           int iterations \x3d 128;\n           float contrast \x3d 0.8;\n           vec2 movement \x3d vec2(1.0);\n\n             float fadefactor \x3d 1.0/float(iterations);\n           float multiplier \x3d 1.4;\n           for( int i\x3d0; i\x3c128; i++ ) {\n               vec3 texturesample \x3d texture2D(tDiffuse,position+temp_position).xyz;\n               accumulation +\x3d multiplier*smoothstep(0.1,1.0,texturesample*texturesample);\n               multiplier *\x3d 1.0-fadefactor;\n               temp_position +\x3d ((movement*0.25)-position)/float(iterations);\n           };\n\n           accumulation /\x3d float(iterations);\n\n           vec3 color \x3d texture2D(tDiffuse,custom_glFragCoord).rgb+(accumulation*(contrast/(1.0+dot(position,position))));\n\n             gl_FragColor \x3d  vec4( color, cTextureScreen.a );\n\n        }\n\n"};THREE.SMAAShader=[{defines:{SMAA_THRESHOLD:"0.1"},uniforms:{tDiffuse:{value:null},resolution:{value:new THREE.Vector2(1/1024,1/512)}},vertexShader:"uniform vec2 resolution;\nvarying vec2 vUv;\nvarying vec4 vOffset[ 3 ];\nvoid SMAAEdgeDetectionVS( vec2 texcoord ) {\nvOffset[ 0 ] \x3d texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );\nvOffset[ 1 ] \x3d texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );\nvOffset[ 2 ] \x3d texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );\n}\nvoid main() {\nvUv \x3d uv;\nSMAAEdgeDetectionVS( vUv );\ngl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvarying vec4 vOffset[ 3 ];\nvec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {\nvec2 threshold \x3d vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );\nvec4 delta;\nvec3 C \x3d texture2D( colorTex, texcoord ).rgb;\nvec3 Cleft \x3d texture2D( colorTex, offset[0].xy ).rgb;\nvec3 t \x3d abs( C - Cleft );\ndelta.x \x3d max( max( t.r, t.g ), t.b );\nvec3 Ctop \x3d texture2D( colorTex, offset[0].zw ).rgb;\nt \x3d abs( C - Ctop );\ndelta.y \x3d max( max( t.r, t.g ), t.b );\nvec2 edges \x3d step( threshold, delta.xy );\nif ( dot( edges, vec2( 1.0, 1.0 ) ) \x3d\x3d 0.0 )\ndiscard;\nvec3 Cright \x3d texture2D( colorTex, offset[1].xy ).rgb;\nt \x3d abs( C - Cright );\ndelta.z \x3d max( max( t.r, t.g ), t.b );\nvec3 Cbottom  \x3d texture2D( colorTex, offset[1].zw ).rgb;\nt \x3d abs( C - Cbottom );\ndelta.w \x3d max( max( t.r, t.g ), t.b );\nfloat maxDelta \x3d max( max( max( delta.x, delta.y ), delta.z ), delta.w );\nvec3 Cleftleft  \x3d texture2D( colorTex, offset[2].xy ).rgb;\nt \x3d abs( C - Cleftleft );\ndelta.z \x3d max( max( t.r, t.g ), t.b );\nvec3 Ctoptop \x3d texture2D( colorTex, offset[2].zw ).rgb;\nt \x3d abs( C - Ctoptop );\ndelta.w \x3d max( max( t.r, t.g ), t.b );\nmaxDelta \x3d max( max( maxDelta, delta.z ), delta.w );\nedges.xy *\x3d step( 0.5 * maxDelta, delta.xy );\nreturn vec4( edges, 0.0, 0.0 );\n}\nvoid main() {\ngl_FragColor \x3d SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );\n}"},{defines:{SMAA_MAX_SEARCH_STEPS:"8",SMAA_AREATEX_MAX_DISTANCE:"16",SMAA_AREATEX_PIXEL_SIZE:"( 1.0 / vec2( 160.0, 560.0 ) )",SMAA_AREATEX_SUBTEX_SIZE:"( 1.0 / 7.0 )"},uniforms:{tDiffuse:{value:null},tArea:{value:null},tSearch:{value:null},resolution:{value:new THREE.Vector2(1/1024,1/512)}},vertexShader:"uniform vec2 resolution;\nvarying vec2 vUv;\nvarying vec4 vOffset[ 3 ];\nvarying vec2 vPixcoord;\nvoid SMAABlendingWeightCalculationVS( vec2 texcoord ) {\nvPixcoord \x3d texcoord / resolution;\nvOffset[ 0 ] \x3d texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );\nvOffset[ 1 ] \x3d texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );\nvOffset[ 2 ] \x3d vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );\n}\nvoid main() {\nvUv \x3d uv;\nSMAABlendingWeightCalculationVS( vUv );\ngl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )\nuniform sampler2D tDiffuse;\nuniform sampler2D tArea;\nuniform sampler2D tSearch;\nuniform vec2 resolution;\nvarying vec2 vUv;\nvarying vec4 vOffset[3];\nvarying vec2 vPixcoord;\nvec2 round( vec2 x ) {\nreturn sign( x ) * floor( abs( x ) + 0.5 );\n}\nfloat SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {\ne.r \x3d bias + e.r * scale;\nreturn 255.0 * texture2D( searchTex, e, 0.0 ).r;\n}\nfloat SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\nvec2 e \x3d vec2( 0.0, 1.0 );\nfor ( int i \x3d 0; i \x3c SMAA_MAX_SEARCH_STEPS; i ++ ) {\ne \x3d texture2D( edgesTex, texcoord, 0.0 ).rg;\ntexcoord -\x3d vec2( 2.0, 0.0 ) * resolution;\nif ( ! ( texcoord.x \x3e end \x26\x26 e.g \x3e 0.8281 \x26\x26 e.r \x3d\x3d 0.0 ) ) break;\n}\ntexcoord.x +\x3d 0.25 * resolution.x;\ntexcoord.x +\x3d resolution.x;\ntexcoord.x +\x3d 2.0 * resolution.x;\ntexcoord.x -\x3d resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);\nreturn texcoord.x;\n}\nfloat SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\nvec2 e \x3d vec2( 0.0, 1.0 );\nfor ( int i \x3d 0; i \x3c SMAA_MAX_SEARCH_STEPS; i ++ ) {\ne \x3d texture2D( edgesTex, texcoord, 0.0 ).rg;\ntexcoord +\x3d vec2( 2.0, 0.0 ) * resolution;\nif ( ! ( texcoord.x \x3c end \x26\x26 e.g \x3e 0.8281 \x26\x26 e.r \x3d\x3d 0.0 ) ) break;\n}\ntexcoord.x -\x3d 0.25 * resolution.x;\ntexcoord.x -\x3d resolution.x;\ntexcoord.x -\x3d 2.0 * resolution.x;\ntexcoord.x +\x3d resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );\nreturn texcoord.x;\n}\nfloat SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\nvec2 e \x3d vec2( 1.0, 0.0 );\nfor ( int i \x3d 0; i \x3c SMAA_MAX_SEARCH_STEPS; i ++ ) {\ne \x3d texture2D( edgesTex, texcoord, 0.0 ).rg;\ntexcoord +\x3d vec2( 0.0, 2.0 ) * resolution;\nif ( ! ( texcoord.y \x3e end \x26\x26 e.r \x3e 0.8281 \x26\x26 e.g \x3d\x3d 0.0 ) ) break;\n}\ntexcoord.y -\x3d 0.25 * resolution.y;\ntexcoord.y -\x3d resolution.y;\ntexcoord.y -\x3d 2.0 * resolution.y;\ntexcoord.y +\x3d resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );\nreturn texcoord.y;\n}\nfloat SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\nvec2 e \x3d vec2( 1.0, 0.0 );\nfor ( int i \x3d 0; i \x3c SMAA_MAX_SEARCH_STEPS; i ++ ) {\ne \x3d texture2D( edgesTex, texcoord, 0.0 ).rg;\ntexcoord -\x3d vec2( 0.0, 2.0 ) * resolution;\nif ( ! ( texcoord.y \x3c end \x26\x26 e.r \x3e 0.8281 \x26\x26 e.g \x3d\x3d 0.0 ) ) break;\n}\ntexcoord.y +\x3d 0.25 * resolution.y;\ntexcoord.y +\x3d resolution.y;\ntexcoord.y +\x3d 2.0 * resolution.y;\ntexcoord.y -\x3d resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );\nreturn texcoord.y;\n}\nvec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {\nvec2 texcoord \x3d float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;\ntexcoord \x3d SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );\ntexcoord.y +\x3d SMAA_AREATEX_SUBTEX_SIZE * offset;\nreturn texture2D( areaTex, texcoord, 0.0 ).rg;\n}\nvec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {\nvec4 weights \x3d vec4( 0.0, 0.0, 0.0, 0.0 );\nvec2 e \x3d texture2D( edgesTex, texcoord ).rg;\nif ( e.g \x3e 0.0 ) {\nvec2 d;\nvec2 coords;\ncoords.x \x3d SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );\ncoords.y \x3d offset[ 1 ].y;\nd.x \x3d coords.x;\nfloat e1 \x3d texture2D( edgesTex, coords, 0.0 ).r;\ncoords.x \x3d SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );\nd.y \x3d coords.x;\nd \x3d d / resolution.x - pixcoord.x;\nvec2 sqrt_d \x3d sqrt( abs( d ) );\ncoords.y -\x3d 1.0 * resolution.y;\nfloat e2 \x3d SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;\nweights.rg \x3d SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );\n}\nif ( e.r \x3e 0.0 ) {\nvec2 d;\nvec2 coords;\ncoords.y \x3d SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );\ncoords.x \x3d offset[ 0 ].x;\nd.x \x3d coords.y;\nfloat e1 \x3d texture2D( edgesTex, coords, 0.0 ).g;\ncoords.y \x3d SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );\nd.y \x3d coords.y;\nd \x3d d / resolution.y - pixcoord.y;\nvec2 sqrt_d \x3d sqrt( abs( d ) );\ncoords.y -\x3d 1.0 * resolution.y;\nfloat e2 \x3d SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;\nweights.ba \x3d SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );\n}\nreturn weights;\n}\nvoid main() {\ngl_FragColor \x3d SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );\n}"},{uniforms:{tDiffuse:{value:null},tColor:{value:null},resolution:{value:new THREE.Vector2(1/1024,1/512)}},vertexShader:"uniform vec2 resolution;\nvarying vec2 vUv;\nvarying vec4 vOffset[ 2 ];\nvoid SMAANeighborhoodBlendingVS( vec2 texcoord ) {\nvOffset[ 0 ] \x3d texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );\nvOffset[ 1 ] \x3d texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );\n}\nvoid main() {\nvUv \x3d uv;\nSMAANeighborhoodBlendingVS( vUv );\ngl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D tDiffuse;\nuniform sampler2D tColor;\nuniform vec2 resolution;\nvarying vec2 vUv;\nvarying vec4 vOffset[ 2 ];\nvec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {\nvec4 a;\na.xz \x3d texture2D( blendTex, texcoord ).xz;\na.y \x3d texture2D( blendTex, offset[ 1 ].zw ).g;\na.w \x3d texture2D( blendTex, offset[ 1 ].xy ).a;\nif ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) \x3c 1e-5 ) {\nreturn texture2D( colorTex, texcoord, 0.0 );\n} else {\nvec2 offset;\noffset.x \x3d a.a \x3e a.b ? a.a : -a.b;\noffset.y \x3d a.g \x3e a.r ? -a.g : a.r;\nif ( abs( offset.x ) \x3e abs( offset.y )) {\noffset.y \x3d 0.0;\n} else {\noffset.x \x3d 0.0;\n}\nvec4 C \x3d texture2D( colorTex, texcoord, 0.0 );\ntexcoord +\x3d sign( offset ) * resolution;\nvec4 Cop \x3d texture2D( colorTex, texcoord, 0.0 );\nfloat s \x3d abs( offset.x ) \x3e abs( offset.y ) ? abs( offset.x ) : abs( offset.y );\nC.xyz \x3d pow(C.xyz, vec3(2.2));\nCop.xyz \x3d pow(Cop.xyz, vec3(2.2));\nvec4 mixed \x3d mix(C, Cop, s);\nmixed.xyz \x3d pow(mixed.xyz, vec3(1.0 / 2.2));\nreturn mixed;\n}\n}\nvoid main() {\ngl_FragColor \x3d SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );\n}"}];THREE.SMAAPass=function(a,b){THREE.Pass.call(this);this.edgesRT=new THREE.WebGLRenderTarget(a,b,{depthBuffer:!1,stencilBuffer:!1,generateMipmaps:!1,minFilter:THREE.LinearFilter,format:THREE.RGBFormat});this.edgesRT.texture.name="SMAAPass.edges";this.weightsRT=new THREE.WebGLRenderTarget(a,b,{depthBuffer:!1,stencilBuffer:!1,generateMipmaps:!1,minFilter:THREE.LinearFilter,format:THREE.RGBAFormat});this.weightsRT.texture.name="SMAAPass.weights";var c=this,d=new Image;d.src=this.getAreaTexture();d.onload=function(){c.areaTexture.needsUpdate=!0};this.areaTexture=new THREE.Texture;this.areaTexture.name="SMAAPass.area";this.areaTexture.image=d;this.areaTexture.format=THREE.RGBFormat;this.areaTexture.minFilter=THREE.LinearFilter;this.areaTexture.generateMipmaps=!1;this.areaTexture.flipY=!1;d=new Image;d.src=this.getSearchTexture();d.onload=function(){c.searchTexture.needsUpdate=!0};this.searchTexture=new THREE.Texture;this.searchTexture.name="SMAAPass.search";this.searchTexture.image=d;this.searchTexture.magFilter=THREE.NearestFilter;this.searchTexture.minFilter=THREE.NearestFilter;this.searchTexture.generateMipmaps=!1;this.searchTexture.flipY=!1;void 0===THREE.SMAAShader&&console.error("THREE.SMAAPass relies on THREE.SMAAShader");this.uniformsEdges=THREE.UniformsUtils.clone(THREE.SMAAShader[0].uniforms);this.uniformsEdges.resolution.value.set(1/a,1/b);this.materialEdges=new THREE.ShaderMaterial({defines:Object.assign({},THREE.SMAAShader[0].defines),uniforms:this.uniformsEdges,vertexShader:THREE.SMAAShader[0].vertexShader,fragmentShader:THREE.SMAAShader[0].fragmentShader});this.uniformsWeights=THREE.UniformsUtils.clone(THREE.SMAAShader[1].uniforms);this.uniformsWeights.resolution.value.set(1/a,1/b);this.uniformsWeights.tDiffuse.value=this.edgesRT.texture;this.uniformsWeights.tArea.value=this.areaTexture;this.uniformsWeights.tSearch.value=this.searchTexture;this.materialWeights=new THREE.ShaderMaterial({defines:Object.assign({},THREE.SMAAShader[1].defines),uniforms:this.uniformsWeights,vertexShader:THREE.SMAAShader[1].vertexShader,fragmentShader:THREE.SMAAShader[1].fragmentShader});this.uniformsBlend=THREE.UniformsUtils.clone(THREE.SMAAShader[2].uniforms);this.uniformsBlend.resolution.value.set(1/a,1/b);this.uniformsBlend.tDiffuse.value=this.weightsRT.texture;this.materialBlend=new THREE.ShaderMaterial({uniforms:this.uniformsBlend,vertexShader:THREE.SMAAShader[2].vertexShader,fragmentShader:THREE.SMAAShader[2].fragmentShader});this.needsSwap=!1;this.fsQuad=new THREE.Pass.FullScreenQuad(null)};THREE.SMAAPass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.SMAAPass,render:function(a,b,c,d,e){this.uniformsEdges.tDiffuse.value=c.texture;this.fsQuad.material=this.materialEdges;a.setRenderTarget(this.edgesRT);this.clear&&a.clear();this.fsQuad.render(a);this.fsQuad.material=this.materialWeights;a.setRenderTarget(this.weightsRT);this.clear&&a.clear();this.fsQuad.render(a);this.uniformsBlend.tColor.value=c.texture;this.fsQuad.material=this.materialBlend;this.renderToScreen?a.setRenderTarget(null):(a.setRenderTarget(b),this.clear&&a.clear());this.fsQuad.render(a)},setSize:function(a,b){this.edgesRT.setSize(a,b);this.weightsRT.setSize(a,b);this.materialEdges.uniforms.resolution.value.set(1/a,1/b);this.materialWeights.uniforms.resolution.value.set(1/a,1/b);this.materialBlend.uniforms.resolution.value.set(1/a,1/b)},getAreaTexture:function(){return"data:image/png;base64,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\x3d"},getSearchTexture:function(){return"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII\x3d"}});THREE.OutlinePass=function(a,b,c,d){this.renderScene=b;this.renderCamera=c;this.selectedObjects=void 0!==d?d:[];this.visibleEdgeColor=new THREE.Color(1,1,1);this.hiddenEdgeColor=new THREE.Color(.1,.04,.02);this.edgeGlow=0;this.usePatternTexture=!1;this.edgeThickness=1;this.edgeStrength=3;this.downSampleRatio=2;this.pulsePeriod=0;THREE.Pass.call(this);this.resolution=void 0!==a?new THREE.Vector2(a.x,a.y):new THREE.Vector2(256,256);a={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat};b=Math.round(this.resolution.x/this.downSampleRatio);c=Math.round(this.resolution.y/this.downSampleRatio);this.maskBufferMaterial=new THREE.MeshBasicMaterial({color:16777215});this.maskBufferMaterial.side=THREE.DoubleSide;this.renderTargetMaskBuffer=new THREE.WebGLRenderTarget(this.resolution.x,this.resolution.y,a);this.renderTargetMaskBuffer.texture.name="OutlinePass.mask";this.renderTargetMaskBuffer.texture.generateMipmaps=!1;this.depthMaterial=new THREE.MeshDepthMaterial;this.depthMaterial.side=THREE.DoubleSide;this.depthMaterial.depthPacking=THREE.RGBADepthPacking;this.depthMaterial.blending=THREE.NoBlending;this.prepareMaskMaterial=this.getPrepareMaskMaterial();this.prepareMaskMaterial.side=THREE.DoubleSide;d=this.prepareMaskMaterial;var e;e=this.prepareMaskMaterial.fragmentShader.replace(/DEPTH_TO_VIEW_Z/g,(this.renderCamera.isPerspectiveCamera?"perspective":"orthographic")+"DepthToViewZ");d.fragmentShader=e;this.renderTargetDepthBuffer=new THREE.WebGLRenderTarget(this.resolution.x,this.resolution.y,a);this.renderTargetDepthBuffer.texture.name="OutlinePass.depth";this.renderTargetDepthBuffer.texture.generateMipmaps=!1;this.renderTargetMaskDownSampleBuffer=new THREE.WebGLRenderTarget(b,c,a);this.renderTargetMaskDownSampleBuffer.texture.name="OutlinePass.depthDownSample";this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps=!1;this.renderTargetBlurBuffer1=new THREE.WebGLRenderTarget(b,c,a);this.renderTargetBlurBuffer1.texture.name="OutlinePass.blur1";this.renderTargetBlurBuffer1.texture.generateMipmaps=!1;this.renderTargetBlurBuffer2=new THREE.WebGLRenderTarget(Math.round(b/2),Math.round(c/2),a);this.renderTargetBlurBuffer2.texture.name="OutlinePass.blur2";this.renderTargetBlurBuffer2.texture.generateMipmaps=!1;this.edgeDetectionMaterial=this.getEdgeDetectionMaterial();this.renderTargetEdgeBuffer1=new THREE.WebGLRenderTarget(b,c,a);this.renderTargetEdgeBuffer1.texture.name="OutlinePass.edge1";this.renderTargetEdgeBuffer1.texture.generateMipmaps=!1;this.renderTargetEdgeBuffer2=new THREE.WebGLRenderTarget(Math.round(b/2),Math.round(c/2),a);this.renderTargetEdgeBuffer2.texture.name="OutlinePass.edge2";this.renderTargetEdgeBuffer2.texture.generateMipmaps=!1;this.separableBlurMaterial1=this.getSeperableBlurMaterial(4);this.separableBlurMaterial1.uniforms.texSize.value=new THREE.Vector2(b,c);this.separableBlurMaterial1.uniforms.kernelRadius.value=1;this.separableBlurMaterial2=this.getSeperableBlurMaterial(4);this.separableBlurMaterial2.uniforms.texSize.value=new THREE.Vector2(Math.round(b/2),Math.round(c/2));this.separableBlurMaterial2.uniforms.kernelRadius.value=4;this.overlayMaterial=this.getOverlayMaterial();void 0===THREE.CopyShader&&console.error("THREE.OutlinePass relies on THREE.CopyShader");a=THREE.CopyShader;this.copyUniforms=THREE.UniformsUtils.clone(a.uniforms);this.copyUniforms.opacity.value=1;this.materialCopy=new THREE.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:a.vertexShader,fragmentShader:a.fragmentShader,blending:THREE.NoBlending,depthTest:!1,depthWrite:!1,transparent:!0});this.enabled=!0;this.needsSwap=!1;this.oldClearColor=new THREE.Color;this.oldClearAlpha=1;this.fsQuad=new THREE.Pass.FullScreenQuad(null);this.tempPulseColor1=new THREE.Color;this.tempPulseColor2=new THREE.Color;this.textureMatrix=new THREE.Matrix4};THREE.OutlinePass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.OutlinePass,dispose:function(){this.renderTargetMaskBuffer.dispose();this.renderTargetDepthBuffer.dispose();this.renderTargetMaskDownSampleBuffer.dispose();this.renderTargetBlurBuffer1.dispose();this.renderTargetBlurBuffer2.dispose();this.renderTargetEdgeBuffer1.dispose();this.renderTargetEdgeBuffer2.dispose()},setSize:function(a,b){this.renderTargetMaskBuffer.setSize(a,b);a=Math.round(a/this.downSampleRatio);b=Math.round(b/this.downSampleRatio);this.renderTargetMaskDownSampleBuffer.setSize(a,b);this.renderTargetBlurBuffer1.setSize(a,b);this.renderTargetEdgeBuffer1.setSize(a,b);this.separableBlurMaterial1.uniforms.texSize.value=new THREE.Vector2(a,b);a=Math.round(a/2);b=Math.round(b/2);this.renderTargetBlurBuffer2.setSize(a,b);this.renderTargetEdgeBuffer2.setSize(a,b);this.separableBlurMaterial2.uniforms.texSize.value=new THREE.Vector2(a,b)},changeVisibilityOfSelectedObjects:function(a){function b(b){b.isMesh&&(a?(b.visible=b.userData.oldVisible,delete b.userData.oldVisible):(b.userData.oldVisible=b.visible,b.visible=a))}for(var c=0;c<this.selectedObjects.length;c++)this.selectedObjects[c].traverse(b)},changeVisibilityOfNonSelectedObjects:function(a){function b(a){a.isMesh&&c.push(a)}for(var c=[],d=0;d<this.selectedObjects.length;d++)this.selectedObjects[d].traverse(b);this.renderScene.traverse(function(b){if(b.isMesh||b.isLine||b.isSprite){for(var d=!1,e=0;e<c.length;e++)if(c[e].id===b.id){d=!0;break}if(!d){d=b.visible;if(!a||b.bVisible)b.visible=a;b.bVisible=d}}})},updateTextureMatrix:function(){this.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1);this.textureMatrix.multiply(this.renderCamera.projectionMatrix);this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse)},render:function(a,b,c,d,e){0<this.selectedObjects.length&&(this.oldClearColor.copy(a.getClearColor()),this.oldClearAlpha=a.getClearAlpha(),b=a.autoClear,a.autoClear=!1,e&&a.context.disable(a.context.STENCIL_TEST),a.setClearColor(16777215,1),this.changeVisibilityOfSelectedObjects(!1),d=this.renderScene.background,this.renderScene.background=null,this.renderScene.overrideMaterial=this.depthMaterial,a.setRenderTarget(this.renderTargetDepthBuffer),a.clear(),a.render(this.renderScene,this.renderCamera),this.changeVisibilityOfSelectedObjects(!0),this.updateTextureMatrix(),this.changeVisibilityOfNonSelectedObjects(!1),this.renderScene.overrideMaterial=this.prepareMaskMaterial,this.prepareMaskMaterial.uniforms.cameraNearFar.value=new THREE.Vector2(this.renderCamera.near,this.renderCamera.far),this.prepareMaskMaterial.uniforms.depthTexture.value=this.renderTargetDepthBuffer.texture,this.prepareMaskMaterial.uniforms.textureMatrix.value=this.textureMatrix,a.setRenderTarget(this.renderTargetMaskBuffer),a.clear(),a.render(this.renderScene,this.renderCamera),this.renderScene.overrideMaterial=null,this.changeVisibilityOfNonSelectedObjects(!0),this.renderScene.background=d,this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetMaskBuffer.texture,a.setRenderTarget(this.renderTargetMaskDownSampleBuffer),a.clear(),this.fsQuad.render(a),this.tempPulseColor1.copy(this.visibleEdgeColor),this.tempPulseColor2.copy(this.hiddenEdgeColor),0<this.pulsePeriod&&(d=.625+.75*Math.cos(.01*performance.now()/this.pulsePeriod)/2,this.tempPulseColor1.multiplyScalar(d),this.tempPulseColor2.multiplyScalar(d)),this.fsQuad.material=this.edgeDetectionMaterial,this.edgeDetectionMaterial.uniforms.maskTexture.value=this.renderTargetMaskDownSampleBuffer.texture,this.edgeDetectionMaterial.uniforms.texSize.value=new THREE.Vector2(this.renderTargetMaskDownSampleBuffer.width,this.renderTargetMaskDownSampleBuffer.height),this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value=this.tempPulseColor1,this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value=this.tempPulseColor2,a.setRenderTarget(this.renderTargetEdgeBuffer1),a.clear(),this.fsQuad.render(a),this.fsQuad.material=this.separableBlurMaterial1,this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=THREE.OutlinePass.BlurDirectionX,this.separableBlurMaterial1.uniforms.kernelRadius.value=this.edgeThickness,a.setRenderTarget(this.renderTargetBlurBuffer1),a.clear(),this.fsQuad.render(a),this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetBlurBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=THREE.OutlinePass.BlurDirectionY,a.setRenderTarget(this.renderTargetEdgeBuffer1),a.clear(),this.fsQuad.render(a),this.fsQuad.material=this.separableBlurMaterial2,this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial2.uniforms.direction.value=THREE.OutlinePass.BlurDirectionX,a.setRenderTarget(this.renderTargetBlurBuffer2),a.clear(),this.fsQuad.render(a),this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetBlurBuffer2.texture,this.separableBlurMaterial2.uniforms.direction.value=THREE.OutlinePass.BlurDirectionY,a.setRenderTarget(this.renderTargetEdgeBuffer2),a.clear(),this.fsQuad.render(a),this.fsQuad.material=this.overlayMaterial,this.overlayMaterial.uniforms.maskTexture.value=this.renderTargetMaskBuffer.texture,this.overlayMaterial.uniforms.edgeTexture1.value=this.renderTargetEdgeBuffer1.texture,this.overlayMaterial.uniforms.edgeTexture2.value=this.renderTargetEdgeBuffer2.texture,this.overlayMaterial.uniforms.patternTexture.value=this.patternTexture,this.overlayMaterial.uniforms.edgeStrength.value=this.edgeStrength,this.overlayMaterial.uniforms.edgeGlow.value=this.edgeGlow,this.overlayMaterial.uniforms.usePatternTexture.value=this.usePatternTexture,e&&a.context.enable(a.context.STENCIL_TEST),a.setRenderTarget(c),this.fsQuad.render(a),a.setClearColor(this.oldClearColor,this.oldClearAlpha),a.autoClear=b);this.renderToScreen&&(this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=c.texture,a.setRenderTarget(null),this.fsQuad.render(a))},getPrepareMaskMaterial:function(){return new THREE.ShaderMaterial({uniforms:{depthTexture:{value:null},cameraNearFar:{value:new THREE.Vector2(.5,.5)},textureMatrix:{value:new THREE.Matrix4}},vertexShader:"varying vec4 projTexCoord;\nvarying vec4 vPosition;\nuniform mat4 textureMatrix;\nvoid main() {\n\tvPosition \x3d modelViewMatrix * vec4( position, 1.0 );\n\tvec4 worldPosition \x3d modelMatrix * vec4( position, 1.0 );\n\tprojTexCoord \x3d textureMatrix * worldPosition;\n\tgl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"#include \x3cpacking\x3e\nvarying vec4 vPosition;\nvarying vec4 projTexCoord;\nuniform sampler2D depthTexture;\nuniform vec2 cameraNearFar;\nvoid main() {\n\tfloat depth \x3d unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\tfloat viewZ \x3d - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\n\tfloat depthTest \x3d (-vPosition.z \x3e viewZ) ? 1.0 : 0.0;\n\tgl_FragColor \x3d vec4(0.0, depthTest, 1.0, 1.0);\n}"})},getEdgeDetectionMaterial:function(){return new THREE.ShaderMaterial({uniforms:{maskTexture:{value:null},texSize:{value:new THREE.Vector2(.5,.5)},visibleEdgeColor:{value:new THREE.Vector3(1,1,1)},hiddenEdgeColor:{value:new THREE.Vector3(1,1,1)}},vertexShader:"varying vec2 vUv;\n\r\n\t\t\t\tvoid main() {\n\r\n\t\t\t\t\tvUv \x3d uv;\n\r\n\t\t\t\t\tgl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\r\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\r\n\t\t\t\tuniform sampler2D maskTexture;\r\n\t\t\t\tuniform vec2 texSize;\r\n\t\t\t\tuniform vec3 visibleEdgeColor;\r\n\t\t\t\tuniform vec3 hiddenEdgeColor;\r\n\t\t\t\t\r\n\t\t\t\tvoid main() {\n\r\n\t\t\t\t\tvec2 invSize \x3d 1.0 / texSize;\r\n\t\t\t\t\tvec4 uvOffset \x3d vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\r\n\t\t\t\t\tvec4 c1 \x3d texture2D( maskTexture, vUv + uvOffset.xy);\r\n\t\t\t\t\tvec4 c2 \x3d texture2D( maskTexture, vUv - uvOffset.xy);\r\n\t\t\t\t\tvec4 c3 \x3d texture2D( maskTexture, vUv + uvOffset.yw);\r\n\t\t\t\t\tvec4 c4 \x3d texture2D( maskTexture, vUv - uvOffset.yw);\r\n\t\t\t\t\tfloat diff1 \x3d (c1.r - c2.r)*0.5;\r\n\t\t\t\t\tfloat diff2 \x3d (c3.r - c4.r)*0.5;\r\n\t\t\t\t\tfloat d \x3d length( vec2(diff1, diff2) );\r\n\t\t\t\t\tfloat a1 \x3d min(c1.g, c2.g);\r\n\t\t\t\t\tfloat a2 \x3d min(c3.g, c4.g);\r\n\t\t\t\t\tfloat visibilityFactor \x3d min(a1, a2);\r\n\t\t\t\t\tvec3 edgeColor \x3d 1.0 - visibilityFactor \x3e 0.001 ? visibleEdgeColor : hiddenEdgeColor;\r\n\t\t\t\t\tgl_FragColor \x3d vec4(edgeColor, 1.0) * vec4(d);\r\n\t\t\t\t}"})},getSeperableBlurMaterial:function(a){return new THREE.ShaderMaterial({defines:{MAX_RADIUS:a},uniforms:{colorTexture:{value:null},texSize:{value:new THREE.Vector2(.5,.5)},direction:{value:new THREE.Vector2(.5,.5)},kernelRadius:{value:1}},vertexShader:"varying vec2 vUv;\n\r\n\t\t\t\tvoid main() {\n\r\n\t\t\t\t\tvUv \x3d uv;\n\r\n\t\t\t\t\tgl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\r\n\t\t\t\t}",fragmentShader:"#include \x3ccommon\x3e\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tuniform sampler2D colorTexture;\r\n\t\t\t\tuniform vec2 texSize;\r\n\t\t\t\tuniform vec2 direction;\r\n\t\t\t\tuniform float kernelRadius;\r\n\t\t\t\t\r\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\r\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\r\n\t\t\t\t}\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\tvec2 invSize \x3d 1.0 / texSize;\r\n\t\t\t\t\tfloat weightSum \x3d gaussianPdf(0.0, kernelRadius);\r\n\t\t\t\t\tvec3 diffuseSum \x3d texture2D( colorTexture, vUv).rgb * weightSum;\r\n\t\t\t\t\tvec2 delta \x3d direction * invSize * kernelRadius/float(MAX_RADIUS);\r\n\t\t\t\t\tvec2 uvOffset \x3d delta;\r\n\t\t\t\t\tfor( int i \x3d 1; i \x3c\x3d MAX_RADIUS; i ++ ) {\r\n\t\t\t\t\t\tfloat w \x3d gaussianPdf(uvOffset.x, kernelRadius);\r\n\t\t\t\t\t\tvec3 sample1 \x3d texture2D( colorTexture, vUv + uvOffset).rgb;\r\n\t\t\t\t\t\tvec3 sample2 \x3d texture2D( colorTexture, vUv - uvOffset).rgb;\r\n\t\t\t\t\t\tdiffuseSum +\x3d ((sample1 + sample2) * w);\r\n\t\t\t\t\t\tweightSum +\x3d (2.0 * w);\r\n\t\t\t\t\t\tuvOffset +\x3d delta;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgl_FragColor \x3d vec4(diffuseSum/weightSum, 1.0);\r\n\t\t\t\t}"})},getOverlayMaterial:function(){return new THREE.ShaderMaterial({uniforms:{maskTexture:{value:null},edgeTexture1:{value:null},edgeTexture2:{value:null},patternTexture:{value:null},edgeStrength:{value:1},edgeGlow:{value:1},usePatternTexture:{value:0}},vertexShader:"varying vec2 vUv;\n\r\n\t\t\t\tvoid main() {\n\r\n\t\t\t\t\tvUv \x3d uv;\n\r\n\t\t\t\t\tgl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\r\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\r\n\t\t\t\tuniform sampler2D maskTexture;\r\n\t\t\t\tuniform sampler2D edgeTexture1;\r\n\t\t\t\tuniform sampler2D edgeTexture2;\r\n\t\t\t\tuniform sampler2D patternTexture;\r\n\t\t\t\tuniform float edgeStrength;\r\n\t\t\t\tuniform float edgeGlow;\r\n\t\t\t\tuniform bool usePatternTexture;\r\n\t\t\t\t\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\tvec4 edgeValue1 \x3d texture2D(edgeTexture1, vUv);\r\n\t\t\t\t\tvec4 edgeValue2 \x3d texture2D(edgeTexture2, vUv);\r\n\t\t\t\t\tvec4 maskColor \x3d texture2D(maskTexture, vUv);\r\n\t\t\t\t\tvec4 patternColor \x3d texture2D(patternTexture, 6.0 * vUv);\r\n\t\t\t\t\tfloat visibilityFactor \x3d 1.0 - maskColor.g \x3e 0.0 ? 1.0 : 0.5;\r\n\t\t\t\t\tvec4 edgeValue \x3d edgeValue1 + edgeValue2 * edgeGlow;\r\n\t\t\t\t\tvec4 finalColor \x3d edgeStrength * maskColor.r * edgeValue;\r\n\t\t\t\t\tif(usePatternTexture)\r\n\t\t\t\t\t\tfinalColor +\x3d + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\r\n\t\t\t\t\tgl_FragColor \x3d finalColor;\r\n\t\t\t\t}",blending:THREE.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0})}});THREE.OutlinePass.BlurDirectionX=new THREE.Vector2(1,0);THREE.OutlinePass.BlurDirectionY=new THREE.Vector2(0,1);THREE.SSAARenderPass=function(a,b,c,d){THREE.Pass.call(this);this.scene=a;this.camera=b;this.sampleLevel=4;this.unbiased=!0;this.clearColor=void 0!==c?c:0;this.clearAlpha=void 0!==d?d:0;void 0===THREE.CopyShader&&console.error("THREE.SSAARenderPass relies on THREE.CopyShader");a=THREE.CopyShader;this.copyUniforms=THREE.UniformsUtils.clone(a.uniforms);this.copyMaterial=new THREE.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:a.vertexShader,fragmentShader:a.fragmentShader,premultipliedAlpha:!0,transparent:!0,blending:THREE.AdditiveBlending,depthTest:!1,depthWrite:!1});this.fsQuad=new THREE.Pass.FullScreenQuad(this.copyMaterial)};THREE.SSAARenderPass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.SSAARenderPass,dispose:function(){this.sampleRenderTarget&&(this.sampleRenderTarget.dispose(),this.sampleRenderTarget=null)},setSize:function(a,b){this.sampleRenderTarget&&this.sampleRenderTarget.setSize(a,b)},render:function(a,b,c){this.sampleRenderTarget||(this.sampleRenderTarget=new THREE.WebGLRenderTarget(c.width,c.height,{minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat}),this.sampleRenderTarget.texture.name="SSAARenderPass.sample");var d=THREE.SSAARenderPass.JitterVectors[Math.max(0,Math.min(this.sampleLevel,5))],e=a.autoClear;a.autoClear=!1;var f=a.getClearColor().getHex(),g=a.getClearAlpha(),q=1/d.length;this.copyUniforms.tDiffuse.value=this.sampleRenderTarget.texture;var h=c.width;c=c.height;for(var k=0;k<d.length;k++){var n=d[k];this.camera.setViewOffset&&this.camera.setViewOffset(h,c,.0625*n[0],.0625*n[1],h,c);n=q;this.unbiased&&(n+=.03125*(-.5+(k+.5)/d.length));this.copyUniforms.opacity.value=n;a.setClearColor(this.clearColor,this.clearAlpha);a.setRenderTarget(this.sampleRenderTarget);a.clear();a.render(this.scene,this.camera);a.setRenderTarget(this.renderToScreen?null:b);0===k&&(a.setClearColor(0,0),a.clear());this.fsQuad.render(a)}this.camera.clearViewOffset&&this.camera.clearViewOffset();a.autoClear=e;a.setClearColor(f,g)}});THREE.SSAARenderPass.JitterVectors=[[[0,0]],[[4,4],[-4,-4]],[[-2,-6],[6,-2],[-6,2],[2,6]],[[1,-3],[-1,3],[5,1],[-3,-5],[-5,5],[-7,-1],[3,7],[7,-7]],[[1,1],[-1,-3],[-3,2],[4,-1],[-5,-2],[2,5],[5,3],[3,-5],[-2,6],[0,-7],[-4,-6],[-6,4],[-8,0],[7,-4],[6,7],[-7,-8]],[[-4,-7],[-7,-5],[-3,-5],[-5,-4],[-1,-4],[-2,-2],[-6,-1],[-4,0],[-7,1],[-1,2],[-6,3],[-3,3],[-7,6],[-3,6],[-5,7],[-1,7],[5,-7],[1,-6],[6,-5],[4,-4],[2,-3],[7,-2],[1,-1],[4,-1],[2,1],[6,2],[0,4],[4,4],[2,5],[7,5],[5,6],[3,7]]];THREE.TAARenderPass=function(a,b,c){void 0===THREE.SSAARenderPass&&console.error("THREE.TAARenderPass relies on THREE.SSAARenderPass");THREE.SSAARenderPass.call(this,a,b,c);this.sampleLevel=0;this.accumulate=!1};THREE.TAARenderPass.JitterVectors=THREE.SSAARenderPass.JitterVectors;THREE.TAARenderPass.prototype=Object.assign(Object.create(THREE.SSAARenderPass.prototype),{constructor:THREE.TAARenderPass,render:function(a,b,c,d){if(this.accumulate){var e=THREE.TAARenderPass.JitterVectors[5];this.sampleRenderTarget||(this.sampleRenderTarget=new THREE.WebGLRenderTarget(c.width,c.height,this.params),this.sampleRenderTarget.texture.name="TAARenderPass.sample");this.holdRenderTarget||(this.holdRenderTarget=new THREE.WebGLRenderTarget(c.width,c.height,this.params),this.holdRenderTarget.texture.name="TAARenderPass.hold");this.accumulate&&-1===this.accumulateIndex&&(THREE.SSAARenderPass.prototype.render.call(this,a,this.holdRenderTarget,c,d),this.accumulateIndex=0);d=a.autoClear;a.autoClear=!1;var f=1/e.length;if(0<=this.accumulateIndex&&this.accumulateIndex<e.length){this.copyUniforms.opacity.value=f;this.copyUniforms.tDiffuse.value=b.texture;for(var g=Math.pow(2,this.sampleLevel),q=0;q<g;q++){var h=e[this.accumulateIndex];this.camera.setViewOffset&&this.camera.setViewOffset(c.width,c.height,.0625*h[0],.0625*h[1],c.width,c.height);a.setRenderTarget(b);a.clear();a.render(this.scene,this.camera);a.setRenderTarget(this.sampleRenderTarget);0===this.accumulateIndex&&a.clear();this.fsQuad.render(a);this.accumulateIndex++;if(this.accumulateIndex>=e.length)break}this.camera.clearViewOffset&&this.camera.clearViewOffset()}c=this.accumulateIndex*f;0<c&&(this.copyUniforms.opacity.value=1,this.copyUniforms.tDiffuse.value=this.sampleRenderTarget.texture,a.setRenderTarget(b),a.clear(),this.fsQuad.render(a));1>c&&(this.copyUniforms.opacity.value=1-c,this.copyUniforms.tDiffuse.value=this.holdRenderTarget.texture,a.setRenderTarget(b),0===c&&a.clear(),this.fsQuad.render(a));a.autoClear=d}else THREE.SSAARenderPass.prototype.render.call(this,a,b,c,d),this.accumulateIndex=-1}});THREE.BokehShader={defines:{DEPTH_PACKING:1,PERSPECTIVE_CAMERA:1},uniforms:{tColor:{value:null},tDepth:{value:null},focus:{value:1},aspect:{value:1},aperture:{value:.025},maxblur:{value:1},nearClip:{value:1},farClip:{value:1E3}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv \x3d uv;\ngl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"#include \x3ccommon\x3e\nvarying vec2 vUv;\nuniform sampler2D tColor;\nuniform sampler2D tDepth;\nuniform float maxblur;\nuniform float aperture;\nuniform float nearClip;\nuniform float farClip;\nuniform float focus;\nuniform float aspect;\n#include \x3cpacking\x3e\nfloat getDepth( const in vec2 screenPosition ) {\n\t#if DEPTH_PACKING \x3d\x3d 1\n\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\n\t#else\n\treturn texture2D( tDepth, screenPosition ).x;\n\t#endif\n}\nfloat getViewZ( const in float depth ) {\n\t#if PERSPECTIVE_CAMERA \x3d\x3d 1\n\treturn perspectiveDepthToViewZ( depth, nearClip, farClip );\n\t#else\n\treturn orthographicDepthToViewZ( depth, nearClip, farClip );\n\t#endif\n}\nvoid main() {\nvec2 aspectcorrect \x3d vec2( 1.0, aspect );\nfloat viewZ \x3d getViewZ( getDepth( vUv ) );\nfloat factor \x3d ( focus + viewZ );\nvec2 dofblur \x3d vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );\nvec2 dofblur9 \x3d dofblur * 0.9;\nvec2 dofblur7 \x3d dofblur * 0.7;\nvec2 dofblur4 \x3d dofblur * 0.4;\nvec4 col \x3d vec4( 0.0 );\ncol +\x3d texture2D( tColor, vUv.xy );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\ncol +\x3d texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );\ngl_FragColor \x3d col / 41.0;\ngl_FragColor.a \x3d 1.0;\n}"};THREE.BokehPass=function(a,b,c){THREE.Pass.call(this);this.scene=a;this.camera=b;a=void 0!==c.focus?c.focus:1;var d=void 0!==c.aspect?c.aspect:b.aspect,e=void 0!==c.aperture?c.aperture:.025,f=void 0!==c.maxblur?c.maxblur:1;this.renderTargetColor=new THREE.WebGLRenderTarget(c.width||window.innerWidth||1,c.height||window.innerHeight||1,{minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBFormat});this.renderTargetColor.texture.name="BokehPass.color";this.renderTargetDepth=this.renderTargetColor.clone();this.renderTargetDepth.texture.name="BokehPass.depth";this.materialDepth=new THREE.MeshDepthMaterial;this.materialDepth.depthPacking=THREE.RGBADepthPacking;this.materialDepth.blending=THREE.NoBlending;void 0===THREE.BokehShader&&console.error("THREE.BokehPass relies on THREE.BokehShader");c=THREE.BokehShader;var g=THREE.UniformsUtils.clone(c.uniforms);g.tDepth.value=this.renderTargetDepth.texture;g.focus.value=a;g.aspect.value=d;g.aperture.value=e;g.maxblur.value=f;g.nearClip.value=b.near;g.farClip.value=b.far;this.materialBokeh=new THREE.ShaderMaterial({defines:Object.assign({},c.defines),uniforms:g,vertexShader:c.vertexShader,fragmentShader:c.fragmentShader});this.uniforms=g;this.needsSwap=!1;this.fsQuad=new THREE.Pass.FullScreenQuad(this.materialBokeh);this.oldClearColor=new THREE.Color;this.oldClearAlpha=1};THREE.BokehPass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.BokehPass,render:function(a,b,c,d,e){this.scene.overrideMaterial=this.materialDepth;this.oldClearColor.copy(a.getClearColor());this.oldClearAlpha=a.getClearAlpha();a.autoClear=!1;a.setClearColor(16777215);a.setClearAlpha(1);a.setRenderTarget(this.renderTargetDepth);a.clear();a.render(this.scene,this.camera);this.uniforms.tColor.value=c.texture;this.uniforms.nearClip.value=this.camera.near;this.uniforms.farClip.value=this.camera.far;this.renderToScreen?a.setRenderTarget(null):(a.setRenderTarget(b),a.clear());this.fsQuad.render(a);this.scene.overrideMaterial=null;a.setClearColor(this.oldClearColor);a.setClearAlpha(this.oldClearAlpha);a.autoClear=this.oldAutoClear}});THREE.AfterimageShader={uniforms:{damp:{value:.96},tOld:{value:null},tNew:{value:null}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv \x3d uv;\ngl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform float damp;\nuniform sampler2D tOld;\nuniform sampler2D tNew;\nvarying vec2 vUv;\nvec4 when_gt( vec4 x, float y ) {\nreturn max( sign( x - y ), 0.0 );\n}\nvoid main() {\nvec4 texelOld \x3d texture2D( tOld, vUv );\nvec4 texelNew \x3d texture2D( tNew, vUv );\ntexelOld *\x3d damp * when_gt( texelOld, 0.1 );\ngl_FragColor \x3d max(texelNew, texelOld);\n}"};THREE.AfterimagePass=function(a){THREE.Pass.call(this);void 0===THREE.AfterimageShader&&console.error("THREE.AfterimagePass relies on THREE.AfterimageShader");this.shader=THREE.AfterimageShader;this.uniforms=THREE.UniformsUtils.clone(this.shader.uniforms);this.uniforms.damp.value=void 0!==a?a:.96;this.textureComp=new THREE.WebGLRenderTarget(window.innerWidth,window.innerHeight,{minFilter:THREE.LinearFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat});this.textureOld=new THREE.WebGLRenderTarget(window.innerWidth,window.innerHeight,{minFilter:THREE.LinearFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat});this.shaderMaterial=new THREE.ShaderMaterial({uniforms:this.uniforms,vertexShader:this.shader.vertexShader,fragmentShader:this.shader.fragmentShader});this.compFsQuad=new THREE.Pass.FullScreenQuad(this.shaderMaterial);a=new THREE.MeshBasicMaterial;this.copyFsQuad=new THREE.Pass.FullScreenQuad(a)};THREE.AfterimagePass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.AfterimagePass,render:function(a,b,c){this.uniforms.tOld.value=this.textureOld.texture;this.uniforms.tNew.value=c.texture;a.setRenderTarget(this.textureComp);this.compFsQuad.render(a);this.copyFsQuad.material.map=this.textureComp.texture;this.renderToScreen?a.setRenderTarget(null):(a.setRenderTarget(b),this.clear&&a.clear());this.copyFsQuad.render(a);a=this.textureOld;this.textureOld=this.textureComp;this.textureComp=a},setSize:function(a,b){this.textureComp.setSize(a,b);this.textureOld.setSize(a,b)}});